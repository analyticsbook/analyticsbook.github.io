<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Cover | book_migrate.utf8" />
<meta property="og:type" content="book" />


<meta property="og:description" content="Book for analalytics" />




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<meta name="description" content="Book for analalytics">

<title>Cover | book_migrate.utf8</title>

<script src="libs/header-attrs-2.7/header-attrs.js"></script>
<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/envisioned.css" rel="stylesheet" />
<script src="https://use.typekit.net/ajy6rnl.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>
<!-- <link rel="stylesheet" href="css/normalize.css"> -->
<!-- <link rel="stylesheet" href="css/envisioned.css"/> -->
<link rel="stylesheet" href="css/tablesaw-stackonly.css"/>
<link rel="stylesheet" href="css/nudge.css"/>
<link rel="stylesheet" href="css/sourcesans.css"/>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>




</head>

<body>

<!--bookdown:toc:start-->

<nav class="pushy pushy-left" id="TOC">
<ul>
<li><a href="#cover">Cover</a></li>
</ul>
</nav>

<!--bookdown:toc:end-->

<div class="menu-btn"><h3>☰ Menu</h3></div>

<div class="site-overlay"></div>


<div class="row">
<div class="col-sm-12">

<nav class="pushy pushy-left" id="TOC">
<ul>
<li><a href="#cover">Cover</a></li>
</ul>
</nav>

</div>
</div>
<div class="row">
<div class="col-sm-12">

<div id="cover" class="section level1 unnumbered">
<h1>Cover</h1>
<p>```{r echo=FALSE, out.width=“100%,” fig.margin=FALSE, fig.cap="Welcome to the R Graphics Cookbook, a practical guide that provides more than 150 recipes to help you generate high-quality graphs quickly, without having to comb through all the details of R’s graphing systems. Each recipe tackles a specific problem with a solution you can apply to your own project, and includes a discussion of how and why the recipe works.</p>
<p>Read online here for free, or buy a physical copy on Amazon." }
knitr::include_graphics(‘graphics/cover.png,’dpi = 300)</p>
<pre><code>
#  epigraph {-}

\begin{equation*}
\text{&quot;We know } \underbrace{\text{the sound of two hands clapping}}_{Data}. 
\end{equation*}

\begin{equation*}
\text{But what is } \underbrace{\text{the sound of one hand clapping?&quot;}}_{ Analytics}
\end{equation*}
^[J.D. Salinger, *Nine Stories*]


sss margin_note(fdfd)

newthought(fdf) 





# Preface {-}

This book is suitable for an introductory course of data analytics to help students understand some main statistical learning models, such as linear regression, logistic regression, tree models and random forests, ensemble learning, sparse learning, principal component analysis, kernel methods including the support vector machine and kernel regression, etc. Data science practice is a process that should be told as a story, rather than a one-time implementation of one single model. This process is a main focus of this book, with many course materials about exploratory data analysis, residual analysis, and flowcharts to develop and validate models and data pipelines.

There are $10$ chapters. Except for Chapter 1, which gives an overview of the book, each chapter will introduce two or three techniques. For each technique, we will highlight the intuition and rationale behind it. We then articulate the intuition, use math to formulate the learning problem, and present the full version of the analytic formulation. We use R to implement the technique on both simulated or real-world datasets, present the analysis process (together with R code), show the dynamics in the analysis process, and comment on the results. Some Remarks are also made at the end of each chapter to enhance understanding of the techniques, reveal their different natures by other perspectives, reveal their limitations, and mention existing remedies to overcome these limitations.

There are three unique aspects to this book. 

First, instructors will find many small datasets (i.e., consisting of 5---10 data points of 2---4 variables) in this book for models to be manually implemented by students using step-by-step process. The idea is to let students work out pencil solutions and then compare them with results obtained from established R packages. For example, a dataset with $3$ data points and $2$ predictors is used to illustrate how the shooting algorithm of LASSO could be implemented both on paper and in the R package `glmnet`. Another example is that, to understand the concept of the support vector machine (SVM), we use a dataset with $4$ data points and $2$ predictors to illustrate how the dual formulation of SVM could be solved manually. Furthermore, by this small dataset we help students see the connection between the computational algorithm with the geometric pattern of the data, i.e., the correspondence between the numeric solution with the so-called support vectors clearly visible in the scatterplot of the data. 

Second, instructors will find graphical illustrations to explain some methods to students. These angles exploit connections between the methods; for example, the SVM is illustrated as a neural network; the kernel regression is introduced as a departure from the mindset of global models; and the logistic regression model is introduced as a few creative twists of the modeling process to apply the linear method for a binary classification problem, etc. On a larger scale, the connection between classic statistical models with machine learning algorithms is illustrated by focusing on the understanding of the iterative nature of the computational algorithms enabled by computers. We help students develop an eye for a method&#39;s connection with other models that only appear to be different. This understanding will help us know a method&#39;s strength and limitations, the importance of the context, and the assumptions we have carried in our data analysis. 

Third, it is important for students to understand the storytelling component of data science. Data scientists tell stories every day. A story conveys a message, and a skillful data scientist must have the experience that the message changes its shape and meaning, depending on which model is used, how the model is tuned, or what part of the data is used. And some models have assumed a particular storytelling mode or structure. For example, we found hypothesis testing is a difficult concept for students to understand its essence, because it is a &quot;negative&quot; reading of data. It is not to translate what the data says, but to seek evidence from data against the null hypothesis we will need to come up with first. Examples as such will be found in the book to help students have a larger and deeper view of what they will learn.

&lt;!--chapter:end:index.Rmd--&gt;


# Acknowledgments {-}

The first draft of this book was written in the summer of 2017 to be used as the textbook for a new course about Data Analytics (IND E 498) in the Department of Industrial &amp; Systems Engineering of the University of Washington-Seattle. The course participants were mostly senior undergraduate students and first-year graduate students who provided invaluable comments and feedback to improve the book. The authors also thank Ameer Hamza Shakur, Jingshuo Feng, Prof. Xiangyu Chang and his students for their generous help on some figures, R code, and a range of R/LaTex tools. We also thank the Alzheimer&#39;s Disease Neuroimaging Initiative (ADNI, [https://adni.loni.usc.edu/](https://adni.loni.usc.edu/)) for the data used in this book.

In writing this book, we owe great debt to many people who generously share their materials and codes online. During the three-year writing process, we tried our best to acknowledge and cite all the specific resources we have used, and we may still have missed a few. In online communities such as [GitHub.com](GitHub.com) and [stackoverflow.com](stackoverflow.com) and numerous personal websites/blogs, you can find free resources which can help you quickly start a new project. Most importantly, this book in its current form wouldn&#39;t be possible without R and RStudio ([https://www.rstudio.com](https://www.rstudio.com)), `bookdown` ([https://bookdown.org/](https://bookdown.org/))^[Xie, Y., *Bookdown: Authoring Books and Technical Documents with R Markdown*, CRC Press, 2019.], and the Tufte-LaTeX Developers.

Last, but not least, the authors would like to take this opportunity to thank their editor, John Kimmel, for his support and encouragement throughout the development of this book. The authors also would like to thank the anonymous reviewers who have given great comments and the project editor Michele Dimont and the copyeditor&#39;s remarkable work to improve the book. 

\cleardoublepage
\pagenumbering{arabic}

&lt;!--chapter:end:Acknowledgement_python.Rmd--&gt;

# Chapter 2. Abstraction: Regression \&amp; Tree Models {-}

## Overview {-}

Chapter 2 is about *Abstraction*. It concerns how we model and formulate a problem using *specific mathematical models*. Abstraction is powerful. It begins with identification of a few main entities from the problem, and continues to characterize their relationships. Then we focus on the study of these interconnected entities as a pure mathematical system. Consequences can be analytically established within this abstracted framework, while a phenomenon in a concerned context could be identified as special instances, or manifestations, of the abstracted model. In other words, by making abstraction of a real-world problem, we free ourselves from the application context that is usually unbounded and not well defined.


People often adopt a blackbox view of a real-world problem, as shown in Figure \@ref(fig:f2-1). There is one (or more) key performance metrics of the system, called the output variable^[Denoted as $y$, e.g., the yield of a chemical process, the mortality rate of an ICU, the GDP of a nation, etc.], and there is a set of input variables^[Denoted as $x_{1}, x_{2}, \ldots, x_{p}$; also called predictors, covariates, features, and, sometimes, factors.] that may help us predict the output variable. These variables are the *few main entities* identified from the problem, and how the input variables impact the output variable is *one* main type of relationship we develop models to characterize.

&lt;!--

 \small

&lt;div class=&quot;figure&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;(\#fig:unnamed-chunk-1)\label{fig:2-1} The blackbox nature of many data science problems&lt;/p&gt;&lt;img src=&quot;graphics/2_1.png&quot; alt=&quot;\label{fig:2-1} The blackbox nature of many data science problems&quot;  /&gt;&lt;/div&gt;

 \normalsize
--&gt;

  


 \small

&lt;div class=&quot;figure&quot; style=&quot;text-align: center&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;(\#fig:f2-1)The blackbox nature of many data science problems&lt;/p&gt;&lt;img src=&quot;graphics/2_1.png&quot; alt=&quot;The blackbox nature of many data science problems&quot; width=&quot;80%&quot;  /&gt;&lt;/div&gt;

 \normalsize

These relationships are usually unknown, due to our lack of understanding of the system. It is not always plausible or economically feasible to develop a Newtonian style characterization of the system^[I.e., using differential equations.]. Thus, statistical models are needed. They collect data from this blackbox system and build models to characterize the relationship between the input variables and the output variable. Generally, there are two cultures for statistical modeling^[Breiman, L., * Statistical Modeling: The Two Cultures,* Statistical Science, Volume 16, Issue 3, 199-231, 2001.]: One is the **data modeling** culture, while another is the **algorithmic modeling** culture. Linear regression models are examples of the *data modeling* culture; decision tree models are examples of the *algorithmic modeling* culture.

Two goals are shared by the two cultures: (1) to understand the relationships between the predictors and the output, and (2) to predict the output based on the predictors. The two also share some common criteria to evaluate the success of their models, such as the prediction performance. Another commonality they share is a generic form of their models

 

\begin{equation}
\small
    y=f(\boldsymbol{x})+\epsilon,
(\#eq:ch2-genericmodel)
\end{equation}

\noindent where $f(\boldsymbol{x})$ reflects the *signal* part of $y$ that can be ascertained by knowing $\boldsymbol{x}$, and $\epsilon$ reflects the *noise* part of $y$ that remains uncertain even when we know $x$. To better illustrate this, we could annotate the model form in Eq. \@ref(eq:ch2-genericmodel) as^[An interesting book about the antagonism between signal and noise: Silver, N., *The Signal and the Noise: Why So Many Predictions Fail--but Some Don&#39;t*, Penguin Books, 2015. The author&#39;s prediction model, however, failed to predict Donald Trump&#39;s victory of the 2016 US Election.]


 

\begin{equation}
\small
    \underbrace{y}_{data} = \underbrace{f(\boldsymbol{x})}_{signal} + \underbrace{\epsilon}_{noise},
(\#eq:2-genericmodel)
\end{equation}


The two cultures differ in their ideas about how to model these two parts. A brief illustration is shown in Table \@ref(tab:t2-1).




 \small


Table: (\#tab:t2-1)Comparison between the two cultures of models

|                         | $f(\boldsymbol{x})$                     |$\epsilon$                                                            |Ideology                                                               |
|:------------------------|:----------------------------------------|:---------------------------------------------------------------------|:----------------------------------------------------------------------|
|**Data Modeling**        |Explicit form (e.g., linear regression). |Statistical distribution (e.g., Gaussian).                            |Imply *Cause* and *effect*; uncertainty has a structure.               |
|**Algorithmic Modeling** |Implicit form (e.g., tree model).        |Rarely modeled as structured uncertainty; taken as meaningless noise. |More focus on prediction; to *fit* data rather than to *explain* data. |

 \normalsize
                    

An illustration of the *data modeling*, using linear regression model, is shown in Figure \@ref(fig:f2-datamodel). To develop such a model, we need efforts in two endeavors: the modeling of the signal, and the modeling of the noise (also called errors). It was probably the modeling of the errors, rather than the modeling of the signal, that eventually established a science: Statistics^[Errors, as the name suggests, are embarrassment to a theory that claims to be rational. Errors are irrational, like a crack on the smooth surface of rationality. But rationally, if we could find *a law of errors*, we then find the law of irrationality. With that, once again rationality trumps irrationality, and the crack is sealed.]. 


    


 \small

&lt;div class=&quot;figure fullwidth&quot;&gt;
&lt;img src=&quot;graphics/2_datamodel.png&quot; alt=&quot;Illustration of the *ideology* of data modeling, i.e., data is used to calibrate, or, estimate, the parameters of a pre-specified mathematical structure&quot; width=&quot;80%&quot;  /&gt;
&lt;p class=&quot;caption marginnote shownote&quot;&gt;(\#fig:f2-datamodel)Illustration of the *ideology* of data modeling, i.e., data is used to calibrate, or, estimate, the parameters of a pre-specified mathematical structure&lt;/p&gt;
&lt;/div&gt;

 \normalsize

One only needs to take a look at the beautiful form of the normal distribution (and notice the name as well) to have an impression of its grand status as the law of errors. Comparing with other candidate forms that historically were its competitors, this concentrated, symmetrical, round and smooth form seems a more rational form that a law should take, i.e., see Figure \@ref(fig:f2-errorlaws).

    


 \small

&lt;div class=&quot;figure fullwidth&quot;&gt;
&lt;img src=&quot;graphics/2_errorlaws.png&quot; alt=&quot;Hypothesized laws of errors, including the normal distribution (also called the Gaussian distribution, developed by Gauss in 1809) and some of its old rivalries&quot; width=&quot;80%&quot;  /&gt;
&lt;p class=&quot;caption marginnote shownote&quot;&gt;(\#fig:f2-errorlaws)Hypothesized laws of errors, including the normal distribution (also called the Gaussian distribution, developed by Gauss in 1809) and some of its old rivalries&lt;/p&gt;
&lt;/div&gt;

 \normalsize

The $\epsilon$ in Eq. \@ref(eq:ch2-genericmodel) is often called the **error term**, noise term, or residual term. $\epsilon$ is usually modeled as a Gaussian distribution with mean as $0$. The mean has to be $0$; otherwise, it contradicts with the name *error*. $f(\boldsymbol{x})$ is also called the model of the mean structure^[To see that, notice that $\mathrm{E}{(y)} = \mathrm{E}{[f(\boldsymbol{x}) + \epsilon]} = \mathrm{E}{[f(\boldsymbol{x})]} + \mathrm{E}{[\epsilon]}$. Since $\mathrm{E}{(\epsilon)} = 0$ and $f(\boldsymbol{x})$ is not a random variable, we have $\mathrm{E}{(y)} = f(\boldsymbol{x})$. Thus, $f(\boldsymbol{x})$ essentially predicts the mean of the output variable.].

## Regression models {-}
### Rationale and formulation {-}


Let&#39;s consider a simple regression model, where there is only one predictor $x$ to predict the outcome  $y$. Linear regression model assumes a linear form of  $f(x)$

 

\begin{equation}
\small
f(x)=\beta_{0}+\beta_{1} x ,
(\#eq:2-simLR-fx)
\end{equation}

\noindent where $\beta_0$ is called the **intercept**, and $\beta_1$ is called the **slope**. Both are also called **regression coefficients**, or more generally, **parameters**.

And $\epsilon$ is modeled as a normal distribution^[I.e., could be other types of distributions, but normal distribution is the norm.] with mean $0$,

 

\begin{equation}
\small
\epsilon \sim N\left(0, \sigma_{\varepsilon}^{2}\right),
(\#eq:2-simLR-eps)
\end{equation}

\noindent where $\sigma_{\varepsilon}^{2}$ is the **variance** of the error.

For any given value of $x$, we know the model of $y$ is

 

\begin{equation}
\small
y = \beta_{0}+\beta_{1}x + \epsilon.
(\#eq:2-simLR-y)
\end{equation}

As Figure \@ref(fig:f2-lrpred) reveals, in linear regression model, $y$ is not modeled as a numerical value, but as a distribution. In other words, $y$ itself is treated as a random variable. Its distribution&#39;s mean is modeled by $x$ and the variance is *inherited* from $\epsilon$. Knowing the value of $x$ helps us to determine the *location* of this distribution, but not the *shape*---the shape is always fixed.

  


 \small

&lt;div class=&quot;figure&quot; style=&quot;text-align: center&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;(\#fig:f2-lrpred)In a linear regression model, $y$ is modeled as a distribution as well&lt;/p&gt;&lt;img src=&quot;graphics/2_lrpred.png&quot; alt=&quot;In a linear regression model, $y$ is modeled as a distribution as well&quot; width=&quot;80%&quot;  /&gt;&lt;/div&gt;

 \normalsize

To make a prediction of $y$ for any given $x$, $\beta_{0}+\beta_{1}x$ comes as a natural choice. It is too natural that it is often unnoticed or unquestioned. Nonetheless, to predict a random variable, using its mean is the &quot;best&quot; choice, but it is not the only possibility, as Figure \@ref(fig:f2-lrpred) reveals that $y$ itself is a random variable, and to predict a random variable, we could also use a confidence interval instead of a point estimate. It depends on what you&#39;d like to predict. If the goal is to predict what is the most likely value for $y$ given $x$, then the best guess is $\beta_{0}+\beta_{1}x$.^[An important job for statisticians is to prove some ideas are our best choices, i.e., by showing that these choices are optimal decisions under some specific conditions (accurately defined by mathematical terms). It is often that intuitions come before proofs, so many theories are actually developed retrospectively.]

&lt;!-- \begin{figure} --&gt;
&lt;!--     \checkoddpage \ifoddpage \forcerectofloat \else \forceversofloat \fi --&gt;
&lt;!--    \includegraphics[width=0.95\textwidth]{graphics/2_lrpred.png} --&gt;
&lt;!--    \caption{} --&gt;
&lt;!--    \label{fig:2-lrpred} --&gt;
&lt;!-- \end{figure} --&gt;


There are more assumptions that have been made to enable the model in Eq. \@ref(eq:2-simLR-y).

 
 &lt;!-- begin{itemize} --&gt; 


- There is a linear relationship between $x$ and $y$. And this linear relationship remains the same for all the values of $x$. This is often referred to as a *global* relationship between $x$ and $y$. Sometimes this assumption is considered strong, e.g., as shown in Figure \@ref(fig:f2-2), in drug research it is often found that the dose ($x$) is related to the effect of the drug ($y$) in a varying manner that depends on the value of $x$. Still, from Figure \@ref(fig:f2-2) we can see that the linear line captures an essential component in the relationship between $x$ and $y$, providing a good statistical approximation. Regression models that capture *locality* in the relationship between $x$ and $y$ are introduced in **Chapter 9**.

 


 \small

&lt;p&gt;&lt;span class=&quot;marginnote shownote&quot;&gt;
&lt;!--
&lt;div class=&quot;figure&quot;&gt;--&gt;
&lt;img src=&quot;graphics/2_2.png&quot; alt=&quot;Complex relationship between dose ($x$) and drug response ($y$), while the linear line does provide a good statistical approximation&quot; width=&quot;100%&quot;  /&gt;
&lt;!--
&lt;p class=&quot;caption marginnote&quot;&gt;--&gt;(\#fig:f2-2)Complex relationship between dose ($x$) and drug response ($y$), while the linear line does provide a good statistical approximation&lt;!--&lt;/p&gt;--&gt;
&lt;!--&lt;/div&gt;--&gt;&lt;/span&gt;&lt;/p&gt;

 \normalsize




- The model acknowledges a degree of unpredictability of $y$. Eq. \@ref(eq:2-simLR-y) indicates that $y$ is generated by a combination of the signal (i.e., $\beta_{0}+\beta_{1}x$) and the noise (i.e., $\epsilon$). Since we could never predict noise, we compute a metric called **R-squared** to quantify the predictability of a model
     

\begin{equation}
\small
        \text{R-squared} = \frac{\sigma_{y}^{2}-\sigma_{\varepsilon}^{2}}{\sigma_{y}^{2}}.
(\#eq:2-R2)
    \end{equation}
    Here, $\sigma_{y}^{2}$ is the variance of $y$. The *R-squared* ranges from $0$ (zero predictability) to $1$ (perfect predictability).

- The *significance* of $x$ in predicting $y$, and the *accuracy* of $x$ in predicting $y$, are two different concepts. A predictor $x$ could be inadequate in predicting $y$, i.e., the R-squared could be as low as $0.1$, but it still could be statistically significant. In other words, the relation between $x$ and $y$ is not strong, but it is not spurious either. This often happens in social science research and education research projects. Some scenarios are shown in Figure \@ref(fig:f2-signvsaccu).


    


 \small

&lt;div class=&quot;figure fullwidth&quot;&gt;
&lt;img src=&quot;graphics/2_fourtypes.png&quot; alt=&quot;Significance vs. accuracy&quot; width=&quot;80%&quot;  /&gt;
&lt;p class=&quot;caption marginnote shownote&quot;&gt;(\#fig:f2-signvsaccu)Significance vs. accuracy&lt;/p&gt;
&lt;/div&gt;

 \normalsize


- The noise is usually modeled as a normal distribution, but this assumption could be relaxed. A detailed discussion about how to check the normality assumption in data analysis can be found in **Chapter 5**.
 
 &lt;!-- end{itemize} --&gt; 





### Theory and method {-}

*Parameter estimation.* To estimate a model is to estimate its parameters, i.e., for the model shown in Eq. \@ref(eq:2-simLR-y), unknown parameters include $\beta_{0}$, $\beta_{1}$, and $\sigma_{\varepsilon}^{2}$. Usually, we estimate the regression coefficients first. Then, as shown in Figure \@ref(fig:f2-datamodel), errors could be computed, and further, $\sigma_{\varepsilon}^{2}$ could be estimated^[I.e., as a standard practice of sample variance estimation by taking the residuals (i.e., $\epsilon_1$, $\epsilon_2$ and $\epsilon_3$) as *samples* of the population of *error*.].

A training dataset is collected to estimate the parameters. The basic idea is that the best estimate should lead to a line, as shown in Figure \@ref(fig:f2-datamodel), that fits the training data as close as possible. To quantify this quality of fitness of a line, two principles are shown in Figure \@ref(fig:f2-3): one based on perpendicular offset (left), while another one based on vertical offset (right). History of statistics has chosen the vertical offset as a more favorable approach, since it leads to tractability in analytic forms^[When there were no computers yet, analytic tractability was, and still is, held as a sacred quality of a model.].

  


 \small

&lt;div class=&quot;figure&quot; style=&quot;text-align: center&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;(\#fig:f2-3)Two principles to fit a linear regression model: (left) perpendicular offsets; (right) vertical offsets. The distances between the dots (the training data) with the line (the trained model) provide a quantitative metric of how well the model fits the data.&lt;/p&gt;&lt;img src=&quot;graphics/2_3.png&quot; alt=&quot;Two principles to fit a linear regression model: (left) perpendicular offsets; (right) vertical offsets. The distances between the dots (the training data) with the line (the trained model) provide a quantitative metric of how well the model fits the data.&quot; width=&quot;60%&quot;  /&gt;&lt;/div&gt;

 \normalsize

The principle of minimizing vertical offsets leads to the **least-squares estimation** of linear regression models. We can exercise the least squares estimation using the simple regression model shown in Eq. \@ref(eq:2-simLR-y). The objective, based on the principle suggested in Figure \@ref(fig:f2-3) (right), is to find the line that **minimizes** the **sum of the squared** of the vertical derivations of the observed data points from the line.

Suppose that we have collected $N$ data points, denoted as, $\left(x_{n}, y_{n}\right)$ for $n=1,2, \dots, N$ ^[Data is paired, i.e., $y_{n}$ corresponds to $x_{n}$.]. For each data point, i.e., the $n_{th}$ data point, the residual $\epsilon_{n}$ is defined as

 

\begin{equation}
\small
\epsilon_{n} = y_{n}-\left(\beta_{0}+\beta_{1} x_{n}\right).
(\#eq:2-simLR-res)
\end{equation}

Then, we define the sum of the squared of the vertical derivations of the observed data points from the line as

 

\begin{equation}
\small
l\left(\beta_{0}, \beta_{1}\right)=\sum_{n=1}^{N}\epsilon_{n}^2.
(\#eq:2-simLR-LS)
\end{equation}

Plugging Eq. \@ref(eq:2-simLR-res) in Eq. \@ref(eq:2-simLR-LS) we have

 

\begin{equation}
\small
l\left(\beta_{0}, \beta_{1}\right)=\sum_{n=1}^{N}\left[y_{n}-\left(\beta_{0}+\beta_{1} x_{n}\right)\right]^{2}.
(\#eq:2-simLR-LS-2)
\end{equation}

To estimate $\beta_{0}$ and $\beta_{1}$ is to minimize this least squares **loss function** $l\left(\beta_{0}, \beta_{1}\right)$. This is an **unconstrained continuous optimization** problem. We take derivatives of $l\left(\beta_{0}, \beta_{1}\right)$ regarding the two parameters and set them to be zero, to derive the estimation equations---this is a common practice of the **First Derivative Test**, illustrated in Figure \@ref(fig:f2-1stderivativetest).


 


 \small

&lt;p&gt;&lt;span class=&quot;marginnote shownote&quot;&gt;
&lt;!--
&lt;div class=&quot;figure&quot;&gt;--&gt;
&lt;img src=&quot;graphics/2_1stderivativetest.png&quot; alt=&quot;Illustration of the **First Derivative Test** in optimization, i.e., the optimal solution would lead the first derivative to be zero. It is widely used in statistics and machine learning to find optimal solutions of some model formulations. More applications of this technique can be found in later chapters.&quot; width=&quot;100%&quot;  /&gt;
&lt;!--
&lt;p class=&quot;caption marginnote&quot;&gt;--&gt;(\#fig:f2-1stderivativetest)Illustration of the **First Derivative Test** in optimization, i.e., the optimal solution would lead the first derivative to be zero. It is widely used in statistics and machine learning to find optimal solutions of some model formulations. More applications of this technique can be found in later chapters.&lt;!--&lt;/p&gt;--&gt;
&lt;!--&lt;/div&gt;--&gt;&lt;/span&gt;&lt;/p&gt;

 \normalsize

\begin{equation*}
\small
  
\frac{\partial l\left(\beta_{0}, \beta_{1}\right)}{\partial \beta_{0}}=-2 \sum_{n=1}^{N}\left[y_{n}-\left(\beta_{0}+\beta_{1} x_{n}\right)\right]=0,
 
\end{equation*}
\begin{equation*}
\small
  
\frac{\partial l\left(\beta_{0}, \beta_{1}\right)}{\partial \beta_{1}}=-2 \sum_{n=1}^{N} x_{n}\left[y_{n}-\left(\beta_{0}+\beta_{1} x_{n}\right)\right]=0.
 
\end{equation*}

These two could be rewritten in a more succinct way

\begin{equation*}
\small
  
\left[ \begin{array}{cc}{N} &amp; {\sum_{n=1}^{N} x_{n}} \\ {\sum_{n=1}^{N} x_{n}} &amp; {\sum_{n=1}^{N} x_{n}^{2}}\end{array}\right] \left[ \begin{array}{c}{\beta_{0}} \\ {\beta_{1}}\end{array}\right]=\left[ \begin{array}{c}{\sum_{n=1}^{N} y_{n}} \\ {\sum_{n=1}^{N} x_{n} y_{n}}\end{array}\right].
 
\end{equation*}

We solve these two equations and derive the estimators of $\beta_{0}$ and $\beta_{1}$, denoted as $\hat{\beta}_{0}$ and $\hat{\beta}_{1}$, respectively, as

 

\begin{equation}
\small
    \begin{aligned}
    &amp;\hat{\beta}_{1}=\frac{\sum_{n=1}^{N}\left(x_{n}-\overline{x}\right)\left(y_{n}-\overline{y}\right)}{\sum_{n=1}^{N} x_{n}^{2}-N \overline{x}^{2}}, \\
    &amp;\hat{\beta}_{0}= \overline{y} - \hat{\beta}_{1} \overline{x}.
    \end{aligned}
(\#eq:2-beta-hat-scalar)
\end{equation}

\noindent where $\overline{x}$ and $\overline{y}$ are the sample mean of the two variables, respectively.

There is a structure hidden inside Eq. \@ref(eq:2-beta-hat-scalar). Note that the estimator $\hat{\beta}_{1}$ can be rewritten as

 

\begin{equation}
\small
\hat{\beta}_{1}=\frac{\sum_{n=1}^{N}\left(x_{n}-\overline{x}\right)\left(y_{n}-\overline{y}\right)}{N-1} \Big/ \frac{\sum_{n=1}^{N} x_{n}^{2}-N \overline{x}^{2}}{N-1},
(\#eq:2-beta1hat)
\end{equation}

\noindent and note that the sample variance of $x$ is defined as

\begin{equation*}
\small
  
\operatorname{var}(x)=\frac{\sum_{n=1}^{N} x_{n}^{2}-N \overline{x}^{2}}{N-1},
 
\end{equation*}

\noindent while the numerator in Eq. \@ref(eq:2-beta1hat) is called the **sample covariance**^[The covariance is a measure of the joint variability of two random variables. Denoted as $\operatorname{cov}(x, y)$, the larger the covariance, the stronger the two variables interact.]. 

Thus, we can *re*write the estimators of $\beta_{1}$ and $\beta_{0}$ as

 

\begin{equation}
\small
    \begin{aligned}
    &amp;\hat{\beta}_{1}=\frac{\operatorname{cov}(x, y)}{\operatorname{var}(x)}, \\
    &amp;\hat{\beta}_{0} = \overline{y} - \hat{\beta}_{1} \overline{x}.
    \end{aligned}
(\#eq:2-simLR-LSE)
\end{equation}


*A small data example.* Let&#39;s practice the estimation method using a simple example.  The dataset is shown in Table \@ref(tab:t2-1ex). 




 \small


Table: (\#tab:t2-1ex)An example dataset

|$x$  | $1$  | $3$  | $3$  | $5$  | $5$  | $6$  | $8$  | $9$ |
|:----|:-----|:-----|:-----|:-----|:-----|:-----|:-----|:----|
|$y$  |$2$   |$3$   |$5$   |$4$   |$6$   |$5$   |$7$   |$8$  |

 \normalsize
                    

Following Eq. \@ref(eq:2-beta-hat-scalar) we can get $\beta_0 = -1.0714$ and $\beta_1 = 1.2143$. The R codes to verify your calculation are shown below.


 \small


```r
# Simple example of regression with one predictor
data = data.frame(rbind(c(1,2),c(3,3),c(3,5),
                        c(5,4),c(5,6),c(6,5),
                        c(8,7),c(9,8)))
colnames(data) = c(&quot;Y&quot;,&quot;X&quot;)
str(data)
lm.YX &lt;- lm(Y ~ X, data = data)
summary(lm.YX)</code></pre>
<p></p>
<p><em>Extension to multivariate regression model.</em> Consider a more general case where there are more than one predictor</p>
<p><span class="math display" id="eq:2-multiLR">\[\begin{equation}
\small
    y=\beta_{0}+\sum_{i=1}^{p} \beta_{i} x_{i}+\varepsilon.
\tag{1}
\end{equation}\]</span></p>
<p>To fit this multivariate linear regression model with <span class="math inline">\(p\)</span> predictors, we collect <span class="math inline">\(N\)</span> data points, denoted as</p>
<p><span class="math display">\[\begin{equation*}
\small
  
\boldsymbol{y}=\left[ \begin{array}{c}{y_{1}} \\ {y_{2}} \\ {\vdots} \\ {y_{N}}\end{array}\right], \text {     }  \boldsymbol{X}=\left[ \begin{array}{ccccc}{1} &amp; {x_{11}} &amp; {x_{21}} &amp; {\cdots} &amp; {x_{p 1}} \\ {1} &amp; {x_{12}} &amp; {x_{22}} &amp; {\cdots} &amp; {x_{p 2}} \\ {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} \\ {1} &amp; {x_{1 N}} &amp; {x_{2 N}} &amp; {\cdots} &amp; {x_{p N}}\end{array}\right].
 
\end{equation*}\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{y} \in R^{N \times 1}\)</span> denotes for the <span class="math inline">\(N\)</span> measurements of the outcome variable, and <span class="math inline">\(\boldsymbol{X} \in R^{N \times(p+1)}\)</span> denotes for the data matrix that includes the <span class="math inline">\(N\)</span> measurements of the <span class="math inline">\(p\)</span> input variables and the intercept term, <span class="math inline">\(\beta_{0}\)</span>, i.e., the first column of <span class="math inline">\(\boldsymbol{X}\)</span> corresponds to <span class="math inline">\(\beta_{0}\)</span>.<label for="tufte-sn-1" class="margin-toggle sidenote-number">1</label><input type="checkbox" id="tufte-sn-1" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">1</span> Again, the data is paired, i.e., <span class="math inline">\(y_{n}\)</span> corresponds to <span class="math inline">\(\boldsymbol{x}_n\)</span> that is the <span class="math inline">\(n_{th}\)</span> row of the matrix <span class="math inline">\(\boldsymbol{X}\)</span>.</span></p>
<p>To estimate the regression coefficients in Eq. <a href="#eq:2-multiLR">(1)</a>, again, we use the least squares estimation method. The first step is to calculate the sum of the squared of the vertical derivations of the observed data points from “the line”<label for="tufte-sn-2" class="margin-toggle sidenote-number">2</label><input type="checkbox" id="tufte-sn-2" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">2</span> Here, actually, a hyperplane.</span>. Following Eq. <a href="#eq:2-simLR-res">(<strong>??</strong>)</a>, we can define the residual as</p>
<p><span class="math display" id="eq:2-multiLR-res">\[\begin{equation}
\small
\epsilon_{n} = y_n - \left(\beta_{0}+\sum_{i=1}^{p} \beta_{i} x_{in}\right).
\tag{2}
\end{equation}\]</span></p>
<p>Then, following Eq. <a href="#eq:2-simLR-LS">(<strong>??</strong>)</a>, the sum of the squared of the vertical derivations of the observed data points from “the line” is</p>
<p><span class="math display" id="eq:2-multiLR-LS">\[\begin{equation}
\small
l\left(\beta_{0}, ...,  \beta_{p}\right)=\sum_{n=1}^{N}\epsilon_{n}^2.
\tag{3}
\end{equation}\]</span></p>
<p>This is again an unconstrained continuous optimization problem, that could be solved by the same procedure we have done for the simple linear regression model. Here, we show how a vector-/matrix-based representation of this derivation process could make things easier.</p>
<p>Let’s write up the regression coefficients and residuals in vector forms as</p>
<p><span class="math display">\[\begin{equation*}
\small
  
\boldsymbol{\beta}=\left[ \begin{array}{c}{\beta_{0}} \\ {\beta_{1}} \\ {\vdots} \\ {\beta_{p}}\end{array}\right], \text { and } \boldsymbol{\varepsilon}=\left[ \begin{array}{c}{\varepsilon_{1}} \\ {\varepsilon_{2}} \\ {\vdots} \\ {\varepsilon_{N}}\end{array}\right].
 
\end{equation*}\]</span></p>
<p>Here, <span class="math inline">\(\boldsymbol{\beta} \in R^{(p+1) \times 1}\)</span> denotes for the regression parameters and <span class="math inline">\(\boldsymbol{\varepsilon} \in R^{N \times 1}\)</span> denotes for the <span class="math inline">\(N\)</span> residuals which are assumed to follow a normal distribution with mean as zero and variance as <span class="math inline">\(\sigma_{\varepsilon}^{2}\)</span>.</p>
<p>Then, based on Eq. <a href="#eq:2-multiLR-res">(2)</a>, we rewrite <span class="math inline">\(\boldsymbol{\varepsilon}\)</span> as
<span class="math display">\[\begin{equation*}
\small
  
\boldsymbol{\varepsilon} = \boldsymbol{y} - \boldsymbol{X} \boldsymbol{\beta}.
 
\end{equation*}\]</span></p>
<p>Eq. <a href="#eq:2-multiLR-LS">(3)</a> could be rewritten as</p>
<p><span class="math display" id="eq:2-multiLR-LS-matrix">\[\begin{equation}
\small
l(\boldsymbol{\beta})=(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\beta})^{T}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\beta}).
\tag{4}
\end{equation}\]</span></p>
<p>To estimate <span class="math inline">\(\boldsymbol{\beta}\)</span> is to solve the optimization problem</p>
<p><span class="math display">\[\begin{equation*}
\small
  
\min _{\boldsymbol{\beta}}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\beta})^{T}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\beta}).
 
\end{equation*}\]</span></p>
<p>To solve this problem, we can take the gradients of the objective function regarding <span class="math inline">\(\boldsymbol{\beta}\)</span> and set them to be zero</p>
<p><span class="math display">\[\begin{equation*}
\small
  
\frac{\partial(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\beta})^{T}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\beta})}{\partial \boldsymbol{\beta}}=0,
 
\end{equation*}\]</span></p>
<p>which gives rise to the equation</p>
<p><span class="math display">\[\begin{equation*}
\small
  
\boldsymbol{X}^{T}(\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\beta})=0.
 
\end{equation*}\]</span></p>
<p>This leads to the <strong>least squares estimator</strong> of <span class="math inline">\(\boldsymbol{\beta}\)</span> as</p>
<p><span class="math display" id="eq:2-multiLR-LSE">\[\begin{equation}
\small
  \widehat{\boldsymbol{\beta}}=\left(\boldsymbol{X}^{T} \boldsymbol{X}\right)^{-1} \boldsymbol{X}^{T} \boldsymbol{y}.
\tag{5}
\end{equation}\]</span></p>
<p>A resemblance can be easily detected between the estimator in Eq. <a href="#eq:2-multiLR-LSE">(5)</a> with Eq. <a href="#eq:2-simLR-LSE">(<strong>??</strong>)</a>, by noticing that <span class="math inline">\(\boldsymbol{X}^{T} \boldsymbol{y}\)</span> reflects the correlation<label for="tufte-sn-3" class="margin-toggle sidenote-number">3</label><input type="checkbox" id="tufte-sn-3" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">3</span> I.e., corresponds to <span class="math inline">\(\operatorname{cov}(x, y)\)</span>.</span> between predictors and output, and <span class="math inline">\(\boldsymbol{X}^{T} \boldsymbol{X}\)</span> reflects the variability<label for="tufte-sn-4" class="margin-toggle sidenote-number">4</label><input type="checkbox" id="tufte-sn-4" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">4</span> I.e., corresponds to <span class="math inline">\(\operatorname{var}(x)\)</span>.</span> of the predictors.</p>
<p>Eq. <a href="#eq:2-multiLR-LSE">(5)</a> may come as a surprise to some readers. The regression coefficients, <span class="math inline">\(\boldsymbol{\beta}\)</span>, by their definition, are supposed to only characterize the relationship between <span class="math inline">\(\boldsymbol{x}\)</span> and <span class="math inline">\(y\)</span>. However, from Eq. <a href="#eq:2-multiLR-LSE">(5)</a>, it is clear that the variability of <span class="math inline">\(\boldsymbol{x}\)</span> matters. This is not a contradiction. <span class="math inline">\(\boldsymbol{\beta}\)</span> and <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> are <em>two</em> different entities: <span class="math inline">\(\boldsymbol{\beta}\)</span> is a theoretical concept, while <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> is a statistical estimate. Statisticians have established theories<label for="tufte-sn-5" class="margin-toggle sidenote-number">5</label><input type="checkbox" id="tufte-sn-5" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">5</span> E.g, interested readers may read this book: Ravishanker, N. and Dey, D.K., <em>A First Course in Linear Model Theory</em>, Chapman &amp; Hall/CRC, 2001.</span> to study how well <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> estimates <span class="math inline">\(\boldsymbol{\beta}\)</span>. From Eq. <a href="#eq:2-multiLR-LSE">(5)</a>, it is clear that where we observe the linear system<label for="tufte-sn-6" class="margin-toggle sidenote-number">6</label><input type="checkbox" id="tufte-sn-6" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">6</span> I.e., from which <span class="math inline">\(\boldsymbol{x}\)</span> we take measurement of <span class="math inline">\(y\)</span>’s.</span> matters to the modeling of the system. This is one main motivation of the area called the <strong>Design of Experiments</strong> that aims to identify the best locations of <span class="math inline">\(\boldsymbol{x}\)</span> from which we collect observations of the outcome variable, in order to achieve the best parameter estimation results.</p>
<p>By generalizing the result in Figure <a href="#fig:f2-lrpred"><strong>??</strong></a> on the multivariate regression, we can see that <span class="math inline">\(\boldsymbol{y}\)</span> is a random vector<label for="tufte-sn-7" class="margin-toggle sidenote-number">7</label><input type="checkbox" id="tufte-sn-7" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">7</span> “MVN” stands for Multivariate Normal Distribution. See <strong>Appendix</strong> for background knowledge on MVN.</span>,</p>
<p><span class="math display">\[\begin{equation}
    \boldsymbol{y} \sim \text{MVN}\left(\boldsymbol{X}^{T}\boldsymbol{\beta},\sigma_{\varepsilon}^{2} \boldsymbol{I}\right).
\end{equation}\]</span></p>
<p>And <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span>, as shown in Eq. <a href="#eq:2-multiLR-LSE">(5)</a>, is essentially a <em>function</em> of <span class="math inline">\(\boldsymbol{y}\)</span>. Thus, <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> is a random vector as well. In other words, <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> has a distribution. Because of the normality of <span class="math inline">\(\boldsymbol{y}\)</span>, <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> is also distributed as a normal distribution.</p>
<p>The mean of <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> is <span class="math inline">\(\boldsymbol{\beta}\)</span>, because</p>
<p>And the covariance matrix of <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> is</p>
<p>Because</p>
<p><span class="math display">\[\begin{equation*}
\small
  
\operatorname{cov}(\boldsymbol{y}) = \sigma_{\varepsilon}^{2} \boldsymbol{I},
 
\end{equation*}\]</span></p>
<p>we have</p>
<p><span class="math display">\[\begin{equation*}
\small
  
\operatorname{cov}(\widehat{\boldsymbol{\beta}}) =
\sigma_{\varepsilon}^{2}\left(\boldsymbol{X}^{T} \boldsymbol{X}\right)^{-1}.
 
\end{equation*}\]</span></p>
<p>Thus, we have derived that</p>
<p><span class="math display" id="eq:2-betaDist-matrix">\[\begin{equation}
\small
    \boldsymbol{y} \sim \text{MVN}\left(\boldsymbol{X}^{T}\boldsymbol{\beta},\sigma_{\varepsilon}^{2} \boldsymbol{I}\right)  \Rightarrow \widehat{\boldsymbol{\beta}} \sim \text{MVN}\left[\boldsymbol{\beta},\sigma_{\varepsilon}^{2} \left(\boldsymbol{X}^{T} \boldsymbol{X}\right)^{-1}\right].
\tag{6}
\end{equation}\]</span></p>
<!-- \begin{equation} -->
<!--     \boldsymbol{y} \sim \text{MVN}\left(\boldsymbol{X}^{T}\boldsymbol{\beta}},\sigma_{\varepsilon}^{2} \boldsymbol{I}\right)  \Rightarrow \widehat{\boldsymbol{\beta}} \sim \text{MVN}\left(\boldsymbol{\beta}},\sigma_{\varepsilon}^{2}\left(\boldsymbol{X}^{T} \boldsymbol{X}\right)^{-1}\right). -->
<!-- \end{equation} -->
<p>For each individual parameter <span class="math inline">\(\beta_i\)</span>, we can infer that</p>
<p><span class="math display" id="eq:2-betaDist">\[\begin{equation}
\small
    \hat{\beta}_{i} \sim N\left(\beta_{i}, \frac{\sigma_{\varepsilon}^{2}}{\boldsymbol{x}_{i}^T \boldsymbol{x}_{i}}\right)
\tag{7}
\end{equation}\]</span></p>
<p><em>Hypothesis testing of regression parameters.</em> Eq. <a href="#eq:2-betaDist">(7)</a> lays the foundation for developing hypothesis testing of the regression parameters.</p>
<p>A hypothesis testing begins with a null hypothesis, e.g.,</p>
<p><span class="math display">\[\begin{equation*}
\small
  
H_{0} : \beta_{i}=0.
 
\end{equation*}\]</span></p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-4"></span>
<img src="graphics/2_4.png" alt="The distribution of $\hat{\beta}_{i}$ " width="100%"  />
<!--
<p class="caption marginnote">-->Figure 1: The distribution of <span class="math inline">\(\hat{\beta}_{i}\)</span> <!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p>If the null hypothesis is true, then based on Eq. <a href="#eq:2-betaDist">(7)</a>, we have</p>
<p><span class="math display" id="eq:2-betaDist0">\[\begin{equation}
\small
    \hat{\beta}_{i} \sim N\left(0, \frac{\sigma_{\varepsilon}^{2}}{\boldsymbol{x}_{i}^T \boldsymbol{x}_{i}}\right).
\tag{8}
\end{equation}\]</span></p>
<p>This distribution is shown in Figure <a href="#fig:f2-4">1</a>. It is a graphical display of the possibilities of the values of <span class="math inline">\(\hat{\beta}_{i}\)</span> that we may observe, <em>if</em> <span class="math inline">\(H_{0}\)</span> is true.</p>
<p>Then we can derive further implications. Based on Figure <a href="#fig:f2-4">1</a>, we could define a range of <span class="math inline">\(\hat{\beta}_{i}\)</span> that we believe as most plausible<label for="tufte-sn-8" class="margin-toggle sidenote-number">8</label><input type="checkbox" id="tufte-sn-8" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">8</span> Note that I use the word “plausible” instead of “possible.” Any value is always <em>possible</em>, according to Eq. <a href="#eq:2-betaDist0">(8)</a>. But the <em>possibility</em> is not equally distributed, as shown in Figure <a href="#fig:f2-4">1</a>. Some values are more possible than others.</span>. In other words, if the null hypothesis is true, then it is normal to see <span class="math inline">\(\hat{\beta}_{i}\)</span> in this range. This thought leads to Figure <a href="#fig:f2-5">2</a>. This is <em>what is supposed to be</em>, if the null hypothesis is true. And any value outside of this range is considered as a result of rare chance, noise, or abnormality. We define a level of probability that represents our threshold of rare chance. We coin this threshold level as <span class="math inline">\(\alpha\)</span>.</p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-5"></span>
<img src="graphics/2_5.png" alt="The framework of hypothesis testing" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 2: The framework of hypothesis testing<!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p>With the threshold level <span class="math inline">\(\alpha\)</span>, we conclude that any value of <span class="math inline">\(\hat{\beta}_{i}\)</span> that falls outside of the range is unlikely. If we see <span class="math inline">\(\hat{\beta}_{i}\)</span> falls outside of the range, we reject the null hypothesis <span class="math inline">\(H_{0}\)</span>, based on the conflict between “<em>what is supposed to be</em>” and “<em>what happened to be</em>.”<label for="tufte-sn-9" class="margin-toggle sidenote-number">9</label><input type="checkbox" id="tufte-sn-9" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">9</span> I.e., what we have assumed in <span class="math inline">\(H_{0}\)</span> is <em>what is supposed to be</em>, and what we have observed in data is <em>what happened to be</em>.</span> This framework is shown in Figure <a href="#fig:f2-5">2</a>.</p>
<p>Hypothesis testing is a decision made with risks. We may be wrong: even if the null hypothesis is true, there is still a small probability, <span class="math inline">\(\alpha\)</span>, that we may observe <span class="math inline">\(\hat{\beta}_{i}\)</span> falls outside of the range. But this is not a blind risk. It is a <em>different kind of risk</em>: we have scientifically derived the risk, understood it well, and accepted the risk as a cost.</p>
<div id="r-lab" class="section level3 unnumbered">
<h3>R Lab</h3>
<p>In this section, we illustrate step-by-step a pipeline of R codes to use the linear regression model in real-world data analysis. Real-world data analysis is challenging. The <em>real-world</em> means objectivity, but the <em>real-worldliness</em> suggests subjectivity. The purpose of the R codes in this book serves a similar function as a diving coach who dives into the water to show how the action should be done, but the <em>real-worldliness</em> can only be felt if you also dive into the water and feel the thrill by yourself. Our data analysis examples try to preserve a certain degree of the <em>real-worldliness</em> that embodies both statistical regularities and realistic irregularities<label for="tufte-sn-10" class="margin-toggle sidenote-number">10</label><input type="checkbox" id="tufte-sn-10" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">10</span> Prof. George Box once said, “<em>all models are wrong, some are useful</em>.”</span>. Only the challenge in many real applications is that the boundary between the statistical regularities and realistic irregularities is unclear and undefined.</p>
<p>Having said that, making informed decisions by drawing from rigorous theories, while at the same time, maintaining a critical attitude about theory, are both needed in practices of data analytics.</p>
<p>Here, our data is from a study of Alzheimer’s disease<label for="tufte-sn-11" class="margin-toggle sidenote-number">11</label><input type="checkbox" id="tufte-sn-11" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">11</span> Data were obtained from the Alzheimer’s Disease Neuroimaging Initiative (ADNI) database (<a href="http://adni.loni.usc.edu">http://adni.loni.usc.edu</a>). The ADNI was launched in 2003 as a public-private partnership, led by Principal Investigator Michael W. Weiner, MD. The primary goal of ADNI has been to test whether serial magnetic resonance imaging (MRI), positron emission tomography (PET), other biological markers, and clinical and neuropsychological assessment can be combined to measure the progression of mild cognitive impairment (MCI) and early Alzheimer’s disease (AD).</span> that collected some demographics, genetic, and neuroimaging variables from hundreds of subjects. The goal of this dataset is to use these predictors to predict some outcome variables, e.g., one is called the Mini-Mental State Examination (<code>MMSCORE</code>), which is a clinical score for determining Alzheimer’s disease. It ranges from <span class="math inline">\(1\)</span> to <span class="math inline">\(30\)</span>, while <span class="math inline">\(25\)</span> to <span class="math inline">\(30\)</span> is normal, <span class="math inline">\(20\)</span> to <span class="math inline">\(24\)</span> suggests mild dementia, <span class="math inline">\(13\)</span> to <span class="math inline">\(20\)</span> suggests moderate dementia, and less than <span class="math inline">\(12\)</span> indicates severe dementia.</p>
<p><em>The 5-Step R Pipeline.</em> We start with a pipeline of conducting linear regression analysis in R with 5 steps. Please keep in mind that these 5 steps are not a fixed formula: it is a selection of the authors to make it simple.</p>
<p><strong>Step 1</strong> loads the data into the R work environment.</p>
<p></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1 -&gt; Read data into R workstation</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># RCurl is the R package to read csv file using a link</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RCurl)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;https://raw.githubusercontent.com&quot;</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;/analyticsbook/book/main/data/AD.csv&quot;</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>AD <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="at">text=</span><span class="fu">getURL</span>(url))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># str(AD)</span></span></code></pre></div>
<p></p>
<p><strong>Step 2</strong> is for data preprocessing. This is a standard chunk of code, and it will be used again in future chapters. As this is the first time we see it, here, let’s break it into several pieces. The first piece is to create your <code>X</code> matrix (predictors) and <code>Y</code> vector (outcome variable). The use of <code>X</code> for predictors and <code>Y</code> for outcome are common practice.</p>
<p></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2 -&gt; Data preprocessing.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove variable DX_bl</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>AD <span class="ot">&lt;-</span> AD[ , <span class="sc">-</span><span class="fu">which</span>(<span class="fu">names</span>(AD) <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;DX_bl&quot;</span>))] </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Pick up the first 15 variables for predictors</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> AD[,<span class="dv">1</span><span class="sc">:</span><span class="dv">15</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Pick up the variable MMSCORE for outcome</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">&lt;-</span> AD<span class="sc">$</span>MMSCORE</span></code></pre></div>
<p></p>
<p>Then, we make a <code>data.frame</code> to enclose both the predictors and outcome variable together. Many R functions presume the data are <em>packaged</em> in this way.</p>
<p></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(X,Y)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(data)[<span class="dv">16</span>] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;MMSCORE&quot;</span>)</span></code></pre></div>
<p></p>
<p>Then, we split the data into two parts<label for="tufte-sn-12" class="margin-toggle sidenote-number">12</label><input type="checkbox" id="tufte-sn-12" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">12</span> Usually, there is a client who splits the data for you, sends you the training data only, and withholds the testing data. When you submit your model trained on the training data, the client could verify your model using the testing data. Here, even the dataset we are working on is already the training data, we still split this nominal training data into halves and use one half as the actual training data and the other half as the testing data. Why do we do so? Please see <strong>Chapter 5</strong>.</span>. We name the two parts as <em>training data</em> and <em>testing data</em>, respectively. The training data is to fit the model. The testing data is excluded from the model training: it will be used to test the model after the final model has been selected using the training data solely.</p>
<p></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>) <span class="co"># generate the same random sequence</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a training data (half the original data size)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>train.ix <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(data),<span class="fu">floor</span>( <span class="fu">nrow</span>(data)<span class="sc">/</span><span class="dv">2</span>) )</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>data.train <span class="ot">&lt;-</span> data[train.ix,]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a testing data (half the original data size)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>data.test <span class="ot">&lt;-</span> data[<span class="sc">-</span>train.ix,]</span></code></pre></div>
<p></p>
<p><strong>Step 3</strong> builds up a linear regression model. We use the <code>lm()</code> function to fit the regression model<label for="tufte-sn-13" class="margin-toggle sidenote-number">13</label><input type="checkbox" id="tufte-sn-13" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">13</span> Use <code>lm()</code> for more information.</span>.</p>
<p></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3 -&gt; Use lm() function to build a full </span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># model with all predictors</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>lm.AD <span class="ot">&lt;-</span> <span class="fu">lm</span>(MMSCORE <span class="sc">~</span> ., <span class="at">data =</span> data.train)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(lm.AD)</span></code></pre></div>
<p></p>
<p>The result is shown in below</p>
<p></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="do">## lm(formula = MMSCORE ~ ., data = data.train)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="do">##     Min      1Q  Median      3Q     Max </span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="do">## -6.3662 -0.8555  0.1540  1.1241  4.2517 </span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="do">##             Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="do">## (Intercept) 17.93920    2.38980   7.507 1.16e-12 ***</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="do">## AGE          0.02212    0.01664   1.329 0.185036    </span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="do">## PTGENDER    -0.11141    0.22077  -0.505 0.614280    </span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="do">## PTEDUCAT     0.16943    0.03980   4.257 2.96e-05 ***</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="do">## FDG          0.65003    0.17836   3.645 0.000328 ***</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="do">## AV45        -1.10136    0.62510  -1.762 0.079348 .  </span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="do">## HippoNV      7.66067    1.68395   4.549 8.52e-06 ***</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="do">## e2_1        -0.26059    0.36036  -0.723 0.470291    </span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="do">## e4_1        -0.42123    0.24192  -1.741 0.082925 .  </span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="do">## rs3818361    0.24991    0.21449   1.165 0.245120    </span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="do">## rs744373    -0.25192    0.20787  -1.212 0.226727    </span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="do">## rs11136000  -0.23207    0.21836  -1.063 0.288926    </span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="do">## rs610932    -0.11403    0.21906  -0.521 0.603179    </span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="do">## rs3851179    0.16251    0.21402   0.759 0.448408    </span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="do">## rs3764650    0.47607    0.24428   1.949 0.052470 .  </span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="do">## rs3865444   -0.34550    0.20559  -1.681 0.094149 .  </span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="do">## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="do">## Residual standard error: 1.63 on 242 degrees of freedom</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.3395, Adjusted R-squared:  0.2986 </span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a><span class="do">## F-statistic: 8.293 on 15 and 242 DF,  p-value: 3.575e-15</span></span></code></pre></div>
<p></p>
<p><strong>Step 4</strong> is model selection. There are many variables that are not significant, i.e., their <em>p-values</em> are larger than <span class="math inline">\(0.05\)</span>. The <code>step()</code> function is used for automatic model selection<label for="tufte-sn-14" class="margin-toggle sidenote-number">14</label><input type="checkbox" id="tufte-sn-14" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">14</span> Use <code>help(step)</code> for more information.</span>, i.e., it implements a brute-force approach to identify the best combinations of variables in a linear regression model.</p>
<p></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4 -&gt; use step() to automatically delete </span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># all the insignificant variables</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Automatic model selection</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>lm.AD.reduced <span class="ot">&lt;-</span> <span class="fu">step</span>(lm.AD, <span class="at">direction=</span><span class="st">&quot;backward&quot;</span>, <span class="at">test=</span><span class="st">&quot;F&quot;</span>)</span></code></pre></div>
<p></p>
<p>And the final model the <code>step()</code> function identifies is</p>
<p></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Step:  AIC=259.92</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="do">## MMSCORE ~ PTEDUCAT + FDG + AV45 + HippoNV + e4_1 + rs744373 + </span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="do">##     rs3764650 + rs3865444</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="do">##             Df Sum of Sq    RSS    AIC F value    Pr(&gt;F)    </span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="do">## &lt;none&gt;                   658.95 259.92                      </span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="do">## - rs744373   1     6.015 664.96 260.27  2.2728  0.132934    </span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="do">## - AV45       1     7.192 666.14 260.72  2.7176  0.100511    </span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="do">## - e4_1       1     8.409 667.36 261.19  3.1774  0.075882 .  </span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="do">## - rs3865444  1     8.428 667.38 261.20  3.1848  0.075544 .  </span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="do">## - rs3764650  1    10.228 669.18 261.90  3.8649  0.050417 .  </span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="do">## - FDG        1    40.285 699.24 273.23 15.2226  0.000123 ***</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="do">## - PTEDUCAT   1    44.191 703.14 274.67 16.6988 5.913e-05 ***</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="do">## - HippoNV    1    53.445 712.40 278.04 20.1954 1.072e-05 ***</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="do">## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span></span></code></pre></div>
<p></p>
<p>It can be seen that the predictors that are kept in the <em>final model</em> are all significant. Also, the <code>R-squared</code> is <span class="math inline">\(0.3228\)</span> using the <span class="math inline">\(8\)</span> selected predictors. This is not bad comparing with the <code>R-squared</code>, <span class="math inline">\(0.3395\)</span>, when all the <span class="math inline">\(15\)</span> predictors are used (we call this model the <em>full model</em>).</p>
<p>We compare the full model with the final model using the F-test that is implemented in <code>anova()</code>.</p>
<p></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">anova</span>(lm.AD.reduced,lm.AD)</span></code></pre></div>
<p></p>
<p>The returned result, shown below, implies that it is statistically indistinguishable between the two models (<em>p-value</em> of the F-test is <span class="math inline">\(0.529\)</span>). The model <code>lm.AD.reduced</code> provides an equally good explanation of the data as the full model does, but <code>lm.AD.reduced</code> is more economic. The principle of <strong>Occam’s razor</strong><label for="tufte-sn-15" class="margin-toggle sidenote-number">15</label><input type="checkbox" id="tufte-sn-15" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">15</span> “<em>Other things being equal, simpler explanations are generally better than more complex ones</em>,” is the basic idea of Occam’s razor. Albert Einstein was also quoted with a similar expression: “<em>Everything should be made as simple as possible, but no simpler</em>.”</span> would consider the model <code>lm.AD.reduced</code> more in favor.</p>
<p></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Analysis of Variance Table</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="do">## Model 1: MMSCORE ~ PTEDUCAT + FDG + AV45 + HippoNV +  </span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="do">##     e4_1 + rs744373 + rs3764650 + rs3865444</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="do">## Model 2: MMSCORE ~ AGE + PTGENDER + PTEDUCAT + FDG + AV45 +  </span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="do">##     HippoNV + e2_1 + e4_1 + rs3818361 + rs744373 + rs11136000 +  </span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="do">##     rs610932 + rs3851179 + rs3764650 + rs3865444</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="do">##   Res.Df    RSS Df Sum of Sq      F Pr(&gt;F)</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="do">## 1    249 658.95                           </span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="do">## 2    242 642.73  7    16.218 0.8723  0.529</span></span></code></pre></div>
<p></p>
<p><strong>Step 5</strong> makes prediction. We can use the function <code>predict()</code><label for="tufte-sn-16" class="margin-toggle sidenote-number">16</label><input type="checkbox" id="tufte-sn-16" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">16</span> <code>predict(obj, data)</code></span> which is a function you can find in many R packages. It usually has two main arguments: <code>obj</code> is the model, and <code>data</code> is the data points you want to predict on. Note that, here, we test the model (that was trained on training data) on the testing data. After gathering the predictions, we use the function <code>cor()</code> to measure how close are the predictions with the true outcome values of the testing data. The higher the correlation, the better the predictions.</p>
<p></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 5 -&gt; Predict using your linear regession model</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>pred.lm <span class="ot">&lt;-</span> <span class="fu">predict</span>(lm.AD.reduced, data.test)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co"># For regression model, you can use correlation to measure </span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># how close your predictions with the true outcome </span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"># values of the data points</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="fu">cor</span>(pred.lm, data.test<span class="sc">$</span>MMSCORE)</span></code></pre></div>
<p></p>
<p><em>Beyond the 5-Step Pipeline.</em> The <strong>Exploratory Data Analysis</strong> (<strong>EDA</strong>) is a practical toolbox that consists of many interesting and insightful methods and tools, mostly empirical and graphical. The idea of EDA was promoted by some statisticians<label for="tufte-sn-17" class="margin-toggle sidenote-number">17</label><input type="checkbox" id="tufte-sn-17" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">17</span> E.g., John W. Tukey was a statistician whose career was known to be an advocate of EDA. See his book: <em>Exploratory Data Analysis</em>, Addison-Wesley Publishing Co., 1977.</span>. The EDA could be used before and after we have built the model. For example, a common practice of EDA is to draw the scatterplots to see how potentially the predictors can predict the outcome variable.</p>
<p></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Scatterplot matrix to visualize the relationship</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co"># between outcome variable with continuous predictors</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages(&quot;GGally&quot;)</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(GGally)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># draw the scatterplots and also empirical</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># shapes of the distributions of the variables</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">ggpairs</span>(AD[,<span class="fu">c</span>(<span class="dv">16</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>)],</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>             <span class="at">upper =</span> <span class="fu">list</span>(<span class="at">continuous =</span> <span class="st">&quot;points&quot;</span>),</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>             <span class="at">lower =</span> <span class="fu">list</span>(<span class="at">continuous =</span> <span class="st">&quot;cor&quot;</span>))</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(p)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="fu">qplot</span>(<span class="fu">factor</span>(PTGENDER),</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>      MMSCORE, <span class="at">data =</span> AD,<span class="at">geom=</span><span class="fu">c</span>(<span class="st">&quot;boxplot&quot;</span>), <span class="at">fill =</span> <span class="fu">factor</span>(PTGENDER))</span></code></pre></div>
<p></p>
<p>Figure <a href="#fig:f2-7">3</a> presents the continuous predictors.</p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:f2-7"></span>
<p class="caption marginnote shownote">
Figure 3: Scatterplots of the continuous predictors versus outcome variable
</p>
<img src="graphics/2_7.png" alt="Scatterplots of the continuous predictors versus outcome variable" width="80%"  />
</div>
<p></p>
<p>For the other predictors which are binary, we can use a boxplot, which is shown in Figure <a href="#fig:f2-8">4</a>.</p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:f2-8"></span>
<p class="caption marginnote shownote">
Figure 4: Boxplots of the binary predictors versus outcome variable
</p>
<img src="graphics/2_8.png" alt="Boxplots of the binary predictors versus outcome variable" width="80%"  />
</div>
<p></p>
<p>In what follows we show another case of EDA.</p>
<p>Consider the relationship between <code>MMSCORE</code> and <code>PTEDUCAT</code>, and find a graphical way to investigate if the predictor, <code>AGE</code>, mediates the relationship between <code>MMSCORE</code> and <code>PTEDUCAT</code>. One way to do so is to color the data points in the scatterplot (i.e., the color corresponds to the numerical scale of <code>AGE</code>). The following R codes generate Figure <a href="#fig:f2-9">5</a>.</p>
<p></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># How to detect interaction terms</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co"># by exploratory data analysis (EDA)</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(ggplot2)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(AD, <span class="fu">aes</span>(<span class="at">x =</span> PTEDUCAT, <span class="at">y =</span> MMSCORE))</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> p <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">colour=</span>AGE), <span class="at">size=</span><span class="dv">2</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co"># p &lt;- p + geom_smooth(method = &quot;auto&quot;)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> p <span class="sc">+</span> <span class="fu">labs</span>(<span class="at">title=</span><span class="st">&quot;MMSE versus PTEDUCAT&quot;</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(p)</span></code></pre></div>
<p></p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-9"></span>
<img src="graphics/2_9.png" alt="Scatterplots of `MMSCORE` versus `PTEDUCAT`" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 5: Scatterplots of <code>MMSCORE</code> versus <code>PTEDUCAT</code><!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p>It looks like that the relationship between <code>MMSCORE</code> and <code>PTEDUCAT</code> indeed changes according to different levels of <code>AGE</code>. While this is subtle, we change the strategy and draw two more figures, i.e., we draw the same scatterplot on two levels of <code>AGE</code>, i.e., <code>AGE &lt; 60</code> and <code>AGE &gt; 80</code>. The following R codes generate Figure <a href="#fig:f2-10">6</a>.</p>
<p></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(AD[<span class="fu">which</span>(AD<span class="sc">$</span>AGE <span class="sc">&lt;</span> <span class="dv">60</span>),], </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>            <span class="fu">aes</span>(<span class="at">x =</span> PTEDUCAT, <span class="at">y =</span> MMSCORE))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> p <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">size=</span><span class="dv">2</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> p <span class="sc">+</span> <span class="fu">geom_smooth</span>(<span class="at">method =</span> lm)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> p <span class="sc">+</span> <span class="fu">labs</span>(<span class="at">title=</span><span class="st">&quot;MMSE versus PTEDUCAT when AGE &lt; 60&quot;</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(p)</span></code></pre></div>
<p></p>
<p></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(AD[<span class="fu">which</span>(AD<span class="sc">$</span>AGE <span class="sc">&gt;</span> <span class="dv">80</span>),], </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>            <span class="fu">aes</span>(<span class="at">x =</span> PTEDUCAT, <span class="at">y =</span> MMSCORE))</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> p <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">size=</span><span class="dv">2</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> p <span class="sc">+</span> <span class="fu">geom_smooth</span>(<span class="at">method =</span> lm)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> p <span class="sc">+</span> <span class="fu">labs</span>(<span class="at">title=</span><span class="st">&quot;MMSE versus PTEDUCAT when AGE &gt; 80&quot;</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(p)</span></code></pre></div>
<p></p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:f2-10"></span>
<p class="caption marginnote shownote">
Figure 6: Scatterplots of <code>MMSCORE</code> versus <code>PTEDUCAT</code> when (left) <code>AGE &lt; 60</code> or (right) <code>AGE &gt; 80</code>
</p>
<img src="graphics/2_10_1.png" alt="Scatterplots of `MMSCORE` versus `PTEDUCAT` when (left) `AGE &lt; 60`  or (right) `AGE &gt; 80`" width="49%" height="49%"  /><img src="graphics/2_10_2.png" alt="Scatterplots of `MMSCORE` versus `PTEDUCAT` when (left) `AGE &lt; 60`  or (right) `AGE &gt; 80`" width="49%" height="49%"  />
</div>
<p></p>
<p>Figure <a href="#fig:f2-10">6</a> shows that the relationship between <code>MMSCORE</code> and <code>PTEDUCAT</code> changes dramatically according to different levels of <code>AGE</code>. In other words, it means that the way the predictor <code>PTEDUCAT</code> impacts the outcome <code>MMSCORE</code> is not simply additive as a regular linear regression model would suggest. Rather, the relationship between the two is modified by <code>AGE</code>. This discovery suggests a different mechanism underlying the three variables, as demonstrated in Figure <a href="#fig:f2-lr-interact">7</a>.</p>
<p>We then add an interaction term into the regression model</p>
<p></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fit the multiple linear regression model </span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co"># with an interaction term: AGE*PTEDUCAT</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>lm.AD.int <span class="ot">&lt;-</span> <span class="fu">lm</span>(MMSCORE <span class="sc">~</span> AGE <span class="sc">+</span> PTGENDER <span class="sc">+</span> PTEDUCAT </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>                  <span class="sc">+</span> AGE<span class="sc">*</span>PTEDUCAT, <span class="at">data =</span> AD)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(lm.AD.int)</span></code></pre></div>
<p></p>
<p>We can see that this interaction term is significant.</p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-lr-interact"></span>
<img src="graphics/2_lr_interact.png" alt="Different data-generating mechanisms: (left) additive relationships between predictors and outcome; (right) additive relationships and interaction" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 7: Different data-generating mechanisms: (left) additive relationships between predictors and outcome; (right) additive relationships and interaction<!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="do">## lm(formula = MMSCORE ~ AGE + PTGENDER </span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="do">##     + PTEDUCAT + AGE * PTEDUCAT,</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="do">##     data = AD)</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="do">##     Min      1Q  Median      3Q     Max</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="do">## -8.2571 -0.9204  0.5156  1.4219  4.2975</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="do">##               Estimate Std. Error t value Pr(&gt;|t|)</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="do">## (Intercept)  40.809411   5.500441   7.419 4.93e-13 ***</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="do">## AGE          -0.202043   0.074087  -2.727  0.00661 **</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="do">## PTGENDER     -0.470951   0.187143  -2.517  0.01216 *</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="do">## PTEDUCAT     -0.642352   0.336212  -1.911  0.05662 .</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a><span class="do">## AGE:PTEDUCAT  0.011083   0.004557   2.432  0.01534 *</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="do">## Residual standard error: 2.052 on 512 degrees of freedom</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.07193,    Adjusted R-squared:  0.06468</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="do">## F-statistic:  9.92 on 4 and 512 DF,  p-value: 9.748e-08</span></span></code></pre></div>
<p></p>
</div>
<div id="tree-models" class="section level2 unnumbered">
<h2>Tree models</h2>
<p></p>
<div id="rationale-and-formulation" class="section level3 unnumbered">
<h3>Rationale and formulation</h3>
<p>While the linear regression model is a typical data modeling method, the decision tree model represents a typical method in the category of algorithmic modeling<label for="tufte-sn-18" class="margin-toggle sidenote-number">18</label><input type="checkbox" id="tufte-sn-18" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">18</span> The two types of modeling cultures are discussed in Table <a href="#tab:t2-1"><strong>??</strong></a>.</span>. The linear regression model, given its many origins and implications, builds a model based on a mathematical characterization of the <em>data-generating mechanism</em>, which emphasizes an analytic understanding of the underlying system and how the data is generated from this system<label for="tufte-sn-19" class="margin-toggle sidenote-number">19</label><input type="checkbox" id="tufte-sn-19" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">19</span> I.e., Eq. <a href="#eq:2-simLR-fx">(<strong>??</strong>)</a> explains how <span class="math inline">\(y\)</span> is impacted by <span class="math inline">\(x\)</span>, and Eq. <a href="#eq:2-simLR-eps">(<strong>??</strong>)</a> explains how the rest of <span class="math inline">\(y\)</span> is impacted by a random force. This is illustrated in Figure <a href="#fig:f2-lr-datamodel">8</a>.</span>. This pursuit of “mechanism” is sometimes too much to ask for if we know little about the physics but only the data, since understanding the mechanism of a problem needs experimental science and profound insights. And this pursuit of “mechanism” limits the applicability of a data modeling method when the data don’t seem to follow the data-generating mechanism <em>prescribed</em> by the model.</p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-lr-datamodel"></span>
<img src="graphics/2_lr_datamodel.png" alt="The *data-generating mechanism* of a simple linear regression model" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 8: The <em>data-generating mechanism</em> of a simple linear regression model<!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p>For example, Table <a href="#tab:t2-3">1</a> shows a dataset that has <span class="math inline">\(6\)</span> observations, with two predictors, <em>Weather</em> and <em>Day of week (Dow)</em>, and an outcome variable, <em>Play</em>. Assume that this is a dataset collected by a causal dog walker whose routine includes a sports field.</p>
<p></p>
<p><!--
<caption>--><span class="marginnote shownote"><span id="tab:t2-3">Table 1: </span>Example of a dataset where a decision tree has a home game</span><!--</caption>--></p>
<table>
<thead>
<tr class="header">
<th align="left">ID</th>
<th align="left">Weather</th>
<th align="left">Dow (day of weak)</th>
<th align="left">Play</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">Rainy</td>
<td align="left">Saturday</td>
<td align="left">No</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">Sunny</td>
<td align="left">Saturday</td>
<td align="left">Yes</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">Windy</td>
<td align="left">Tuesday</td>
<td align="left">No</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">Sunny</td>
<td align="left">Saturday</td>
<td align="left">Yes</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left">Sunny</td>
<td align="left">Monday</td>
<td align="left">No</td>
</tr>
<tr class="even">
<td align="left">6</td>
<td align="left">Windy</td>
<td align="left">Saturday</td>
<td align="left">No</td>
</tr>
</tbody>
</table>
<p></p>
<p>It is hard to imagine that, for this dataset, how we can denote the two predictors as <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span> and connect it with the outcome variable <span class="math inline">\(y\)</span> in the form of Eq. <a href="#eq:2-multiLR">(1)</a>, i.e.,</p>
<!-- \ArrowBetweenLines [\Downarrow] -->
<p><span class="math display">\[\begin{equation*}
    \begin{aligned}
    &amp;\text{*Yes*} = \beta_0 + \beta_1 \text{*Rainy*} + \beta_2 \text{*Tuesday*} + \epsilon?
    \end{aligned}
\end{equation*}\]</span></p>
<p>For this dataset, decision tree is a natural fit. As shown in Figure <a href="#fig:f2-11">9</a>, a decision tree contains a <strong>root node</strong>, <strong>inner nodes</strong>, and <strong>decision nodes</strong> (i.e., the shaded leaf nodes of the tree in Figure <a href="#fig:f2-11">9</a>). For any data point to reach its prediction, it starts from the root node, follows the <strong>splitting rules</strong> alongside the arcs to travel through inner nodes, then finally reaches a decision node. For example, consider the data point “<em>Weather = Sunny, Dow = Saturday</em>,” it starts with the root node, “<em>Weather = Sunny?</em>” then goes to inner node “<em>Dow = Saturday?</em>” then reaches the decision node as the left child node of the inner node “<em>Dow = Saturday?</em>” So the decision is “<em>Play = Yes</em>.”</p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-11"></span>
<img src="graphics/2_11.png" alt="Example of a decision tree model" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 9: Example of a decision tree model<!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p>Compare with data modeling methods that hope to build a characterization of the data-generating mechanism, algorithmic modeling methods such as the decision tree mimic <em>heuristics</em> in human reasoning. It is challenging, while unnecessary, to write up a model of algorithmic modeling in mathematical forms as the one shown in Eq. <a href="#eq:2-multiLR">(1)</a>. Algorithmic modeling methods are more <em>semantics-oriented</em>, and more focused on patterns detection and description.</p>
</div>
<div id="theorymethod" class="section level3 unnumbered">
<h3>Theory/Method</h3>
<p>Decision trees could be generated by manual inspection of the data. The one shown in Figure <a href="#fig:f2-11">9</a> could be easily drawn with a few inspection of the 6 data points in Table <a href="#tab:t2-3">1</a>. Automatic algorithms have been developed that can take a dataset as input and generate a decision tree as output. We can see from Figure <a href="#fig:f2-11">9</a> that a key element of a decision tree is the <em>splitting rules</em> that guide a data point to travel through the inner nodes to reach a final decision node (i.e., to reach a decision).</p>
<p>A splitting rule is defined by a variable and the set of values the variable is allowed to take, e.g., in “<em>Weather = Sunny?</em>” “Weather” is the variable and “Sunny” is the set of value. The variable used for splitting is referred to as the <strong>splitting variable</strong>, and the set of value is referred to as the <strong>splitting value</strong>.</p>
<p>We start with the root node. Possible splitting rules are</p>
<p><!-- begin{itemize} --></p>
<ul>
<li><p>“<em>Weather = Sunny?</em>”</p></li>
<li><p>“<em>Dow = Saturday?</em>”</p></li>
<li><p>“<em>Dow = Monday?</em>”</p></li>
<li><p>“<em>Dow = Tuesday?</em>”</p></li>
</ul>
<p><!-- end{itemize} --></p>
<p>Each of the splitting rules will lead to a different root node. Two examples are shown in Figure <a href="#fig:f2-12">10</a>. Which one should we use?</p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:f2-12"></span>
<p class="caption marginnote shownote">
Figure 10: Example of two root nodes
</p>
<img src="graphics/2_12.png" alt="Example of two root nodes" width="80%"  />
</div>
<p></p>
<p>To help us decide on which splitting rule is the best, the concepts <strong>entropy</strong> of data and <strong>information gain</strong> (<strong>IG</strong>) are needed.</p>
<p><em>Entropy and information gain (IG).</em> We can use the concept <strong>entropy</strong> to measure the homogeneity of the data points in a node of the decision tree. It is defined as</p>
<p><span class="math display" id="eq:2-entropy">\[\begin{equation}
\small
e = \sum\nolimits_{i=1,\cdots,K}-P_i\log _{2} P_i.
\tag{9}
\end{equation}\]</span></p>
<p>where <span class="math inline">\(K\)</span> represents the number of classes of the data points in the node<label for="tufte-sn-20" class="margin-toggle sidenote-number">20</label><input type="checkbox" id="tufte-sn-20" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">20</span> E.g., in Table <a href="#tab:t2-3">1</a>, there are <span class="math inline">\(K=2\)</span> classes, <em>Yes</em> and <em>No</em>.</span>, and <span class="math inline">\(P_i\)</span> is the proportion of data points that belong to the class <span class="math inline">\(i\)</span>. The entropy <span class="math inline">\(e\)</span> is defined as zero when the data points in the node all belong to one single class<label for="tufte-sn-21" class="margin-toggle sidenote-number">21</label><input type="checkbox" id="tufte-sn-21" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">21</span> What is more deterministic than this case?</span>. And <span class="math inline">\(e = 1\)</span> is the maximum value for the entropy of a dataset, i.e., try an example with two classes, where <span class="math inline">\(P_1 = 0.5\)</span> and <span class="math inline">\(P_2 = 0.5\)</span>.<label for="tufte-sn-22" class="margin-toggle sidenote-number">22</label><input type="checkbox" id="tufte-sn-22" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">22</span> What is more uncertain than this case?</span></p>
<p>A node that consists of data points that are dominated by one class (i.e., entropy is small) is ready to be made a decision node. If it still has a large entropy, splitting it into two child nodes could help reduce the entropy. Thus, to further split a node, we look for the best splitting rule that can maximize the entropy reduction. This entropy reduction can be measured by <strong>IG</strong>, which is the difference of entropy of the parent node and the average entropy of the two child nodes weighted by their number of data points. It is defined as</p>
<p><span class="math display" id="eq:2-IG">\[\begin{equation}
\small
IG = e_s - \sum\nolimits_{i=1,2} w_i e_i.
\tag{10}
\end{equation}\]</span></p>
<p>Here, <span class="math inline">\(e_s\)</span> is the entropy of the parent node, <span class="math inline">\(e_i\)</span> is the entropy of the child node <span class="math inline">\(i\)</span>, and <span class="math inline">\(w_i\)</span> is the number of data points in the child node <span class="math inline">\(i\)</span> divided by the number of data points in the parent node.</p>
<p>For example, for the left tree in Figure <a href="#fig:f2-12">10</a>, using the definition of entropy in Eq. <a href="#eq:2-entropy">(9)</a>, the entropy of the root node is calculated as</p>
<p><span class="math display">\[\begin{equation*}
\small
  -\frac{4}{6} \log _2 \frac{4}{6} - \frac{2}{6}\log _2 \frac{2}{6}=0.92. 
\end{equation*}\]</span></p>
<p>The entropy of the left child node (“<em>Weather = Sunny</em>”) is</p>
<p><span class="math display">\[\begin{equation*}
\small
  -\frac{2}{3} \log _2 \frac{2}{3} - \frac{1}{3} \log _2 \frac{1}{3}=0.92. 
\end{equation*}\]</span></p>
<p>The entropy of the right child node (“<em>Weather != Sunny</em>”) is <span class="math inline">\(0\)</span> since all three data points (ID = <span class="math inline">\(1,3,6\)</span>) belong to the same class.</p>
<p>Then, using the definition of IG in Eq. <a href="#eq:2-IG">(10)</a>, the IG for the splitting rule “<em>Weather = Sunny</em>” is</p>
<p><span class="math display">\[\begin{equation*}
\small
  IG = 0.92 - \frac{3}{6} \times 0.92 - \frac{3}{6} \times 0=0.46. 
\end{equation*}\]</span></p>
<p>For the tree in Figure <a href="#fig:f2-12">10</a> (right), the entropy of the left child node (“<em>Dow = Saturday</em>”) is</p>
<p><span class="math display">\[\begin{equation*}
\small
  -\frac{2}{4} \log _2 \frac{2}{4} - \frac{2}{4} \log _2 \frac{2}{4} = 1. 
\end{equation*}\]</span></p>
<p>The entropy of the right child node (“<em>Dow != Saturday</em>”) is <span class="math inline">\(0\)</span> since the two data points (ID = 3,5) belong to the same class.</p>
<p>Thus, the IG for the splitting rule “<em>Dow = Saturday</em>” is</p>
<p><span class="math display">\[\begin{equation*}
\small
  IF=0.92-\frac{4}{6} \times 1 - \frac{2}{6} \times 0=0.25. 
\end{equation*}\]</span></p>
<p>As the IG for the splitting rule “<em>Weather = Sunny</em>” is higher, the left tree in Figure <a href="#fig:f2-12">10</a> is a better choice to start the tree.</p>
<p><em>Recursive partitioning.</em> The splitting process discussed above could be repeatedly used, until there is no further need to split a node, i.e., the node contains data points from one single class, which is ideal and almost would never happen in reality; or the node has reached the minimum number of data points<label for="tufte-sn-23" class="margin-toggle sidenote-number">23</label><input type="checkbox" id="tufte-sn-23" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">23</span> It is common to assign a minimum number of data points to prevent the tree-growing algorithm to generate too tiny leaf nodes. This is to prevent “<strong>overfitting</strong>.” Elaborated discussion of overfitting will be provided in <strong>Chapter 5</strong>.</span>. This repetitive splitting process is called <strong>recursive partitioning</strong>.</p>
<p>For instance, the left child node in the tree shown in Figure <a href="#fig:f2-12">10</a> (left) with data points (ID = <span class="math inline">\(2,4,5\)</span>) still has two classes, and can be further split by selecting the next best splitting rule. The right child node has only one class and becomes a decision node labeled with the decision “<em>Play = No</em>.”</p>
<p>This greedy approach, like other greedy optimization approaches, is easy to use. One limitation of greedy approches is that they may find <strong>local optimal</strong> solutions instead of <strong>global optimal</strong> solutions. The optimal choice we made in choosing between the two alternatives in Figure <a href="#fig:f2-12">10</a> is a <em>local</em> optimal choice, and all later nodes of the final tree model are impacted by our decision made on the root node. The <em>optimal root node</em> doesn’t necessarily lead to the <em>optimal tree</em><label for="tufte-sn-24" class="margin-toggle sidenote-number">24</label><input type="checkbox" id="tufte-sn-24" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">24</span> In other words, an optimal tree is the optimal one among all the possible trees, so an optimal root node won’t necessarily lead to an optimal tree.</span>.</p>
<p>An illustration of the risk of getting stuck in a local optimal solution of greedy optimization approaches is shown in Figure <a href="#fig:f2-localoptimal">11</a>. Where the algorithm gets started matters to where it ends up. For this reason, decision tree algorithms are often sensitive to data, i.e., it is not uncommon that a slight change of the dataset may cause a considerable change of the topology of the decision tree.</p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-localoptimal"></span>
<img src="graphics/2_localoptimal.png" alt="A greedy optimization approach starts its adventure from an **initial solution**. Here, $x_1$, $x_2$, $x_3$ are different initial solutions of $3$ usages of the optimization approach, and $3$ *optimal* solutions are found, while only one of them is *globally optimal*." width="100%"  />
<!--
<p class="caption marginnote">-->Figure 11: A greedy optimization approach starts its adventure from an <strong>initial solution</strong>. Here, <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span>, <span class="math inline">\(x_3\)</span> are different initial solutions of <span class="math inline">\(3\)</span> usages of the optimization approach, and <span class="math inline">\(3\)</span> <em>optimal</em> solutions are found, while only one of them is <em>globally optimal</em>.<!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p><em>Tree pruning.</em> To enhance the robustness of the decision tree learned by data-driven approaches such as the recursive partitioning, <strong>pruning</strong> methods could be used to cut down some unstable or insignificant branches. There are <strong>pre-pruning</strong> and <strong>post-pruning</strong> methods. Pre-pruning stops growing a tree when a pre-defined criterion is met. For example, one can set the <strong>depth of a tree</strong> (i.e., the depth of a node is the number of edges from the node to the tree’s root node; the depth of a tree is the maximum depth of its leaf nodes), or the minimum number of data points at the leaf nodes. These approaches need prior knowledge, and they may not necessarily reflect the characteristics of the particular dataset. More data-dependent approaches can be used. For example, we may set a minimum IG threshold to stop growing a tree when the IG is below the threshold. This may cause another problem, i.e., a small IG at an internal node does not necessarily mean its potential child nodes can only have smaller IG values. Therefore, pre-pruning can cause over-simplified trees and thus <strong>underfitted</strong> tree models. In other words, it may be too cautious.</p>
<p>In contrast, post-pruning prunes a tree after it is fully grown. A fully grown model aggressively spans the tree, i.e., by setting the depth of the tree as a large number. To pursue a fully grown tree is to mitigate the risk of underfit. The cost is that it may overfit the data, so post-pruning is needed. Post-pruning starts from the bottom of the tree. If removing an inner node (together with all the descendant nodes) does not increase the error <em>significantly</em>, then it should be pruned. The question is how to evaluate the significance of the increase of error<label for="tufte-sn-25" class="margin-toggle sidenote-number">25</label><input type="checkbox" id="tufte-sn-25" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">25</span> Interested readers may find the discussion in the Remarks section useful.</span>.</p>
<p>We will refer readers to <strong>Chapter 5</strong> for understanding more about concepts such as <strong>empirical error</strong> and <strong>generalization error</strong>. Understanding the difference between them is a key step towards maturity in data analytics. Like the difference between <em>money</em> and <em>currency</em>, the difference will be obvious to you as long as you have seen the difference.</p>
<p><em>Extensions and other considerations.</em></p>
<p><!-- begin{itemize} --></p>
<ul>
<li><p>In our data example in Table <a href="#tab:t2-3">1</a> we only have categorical variables, so candidate splitting rules could be defined relatively easier. For a continuous variable, one approach to identify candidate splitting rules is to order the observed values first, and then, use the average of each pair of consecutive values for splitting.</p></li>
<li><p>If the outcome variable is continuous, we can use the variance of the outcome variable to measure the “entropy” of a node, i.e.,</p></li>
</ul>
<p><span class="math display">\[\begin{equation*}
\small
  v= \sum\nolimits_{n=1}\nolimits^N \left(\bar y - y_n\right)^2 , 
\end{equation*}\]</span></p>
<p>where <span class="math inline">\(y_{n=1,\cdots,N}\)</span> are the values of the outcome variable in the node, and <span class="math inline">\(\bar y\)</span> is the average of the outcome variable. And the information gain can be calculated similarly.</p>
<ul>
<li>Both pre-pruning and post-pruning are useful in practices, and it is hard to say which one is better than the other. There is a belief that post-pruning can often outperform pre-pruning. A better procedure is to use <strong>cross-validation</strong><label for="tufte-sn-26" class="margin-toggle sidenote-number">26</label><input type="checkbox" id="tufte-sn-26" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">26</span> Details are given in <strong>Chapter 5</strong>.</span>. A popular pre-pruning parameter used in the R package <code>rpart</code> is <code>cp</code>, i.e., it sets a value such that all splits need to improve the IG by at least a factor of <code>cp</code> to be approved. This pre-pruning strategy works well in many applications.</li>
</ul>
<p><!-- end{itemize} --></p>
</div>
<div id="r-lab-1" class="section level3 unnumbered">
<h3>R Lab</h3>
<p><em>The 6-Step R Pipeline.</em> We use <code>DX_bl</code> as the outcome variable that is binary<label for="tufte-sn-27" class="margin-toggle sidenote-number">27</label><input type="checkbox" id="tufte-sn-27" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">27</span> In <code>DX_bl</code>, <code>0</code> denotes normal subjects; <code>1</code> denotes diseased subjects.</span>. We use other variables (except <code>ID</code>, <code>TOTAL13</code> and <code>MMSCORE</code>) to predict <code>DX_bl</code>.</p>
<p><strong>Step 1</strong> loads the needed R packages and data into the workspace.</p>
<p></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Key package for decision tree in R: </span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co"># rpart (for building the tree); </span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"># rpart.plot (for drawing the tree)</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RCurl)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rpart)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rpart.plot)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1 -&gt; Read data into R workstation</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;https://raw.githubusercontent.com&quot;</span>,</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;/analyticsbook/book/main/data/AD.csv&quot;</span>)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="at">text=</span><span class="fu">getURL</span>(url))</span></code></pre></div>
<p>
</p>
<p><strong>Step 2</strong> is about data preprocessing.</p>
<p></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2 -&gt; Data preprocessing</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Create your X matrix (predictors) and </span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Y vector (outcome variable)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> data[,<span class="dv">2</span><span class="sc">:</span><span class="dv">16</span>]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">&lt;-</span> data<span class="sc">$</span>DX_bl</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co"># The following code makes sure the variable &quot;DX_bl&quot; </span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co"># is a &quot;factor&quot;.</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;c&quot;</span>, Y) </span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co"># This line is to &quot;factorize&quot; the variable &quot;DX_bl&quot;.</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co"># It denotes &quot;0&quot; as &quot;c0&quot; and &quot;1&quot; as &quot;c1&quot;,</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="co"># to highlight the fact that</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="co"># &quot;DX_bl&quot; is a factor variable, not a numerical variable</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(Y) <span class="co"># as.factor is to convert any variable</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>                  <span class="co"># into the format as &quot;factor&quot; variable.</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Then, we integrate everything into a data frame</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(X,Y)</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(data)[<span class="dv">16</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="st">&quot;DX_bl&quot;</span>)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>) <span class="co"># generate the same random sequence</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a training data (half the original data size)</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>train.ix <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(data),<span class="fu">floor</span>( <span class="fu">nrow</span>(data)<span class="sc">/</span><span class="dv">2</span>) )</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>data.train <span class="ot">&lt;-</span> data[train.ix,]</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a testing data (half the original data size)</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>data.test <span class="ot">&lt;-</span> data[<span class="sc">-</span>train.ix,]</span></code></pre></div>
<p></p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-15"></span>
<img src="graphics/2_15.png" alt="The unpruned decision tree to predict `DX_bl`" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 12: The unpruned decision tree to predict <code>DX_bl</code><!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p><strong>Step 3</strong> is to use the <code>rpart()</code> function in the R package <code>rpart</code> to build the decision tree.</p>
<p></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3 -&gt; use rpart to build the decision tree.</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>tree <span class="ot">&lt;-</span> <span class="fu">rpart</span>(DX_bl <span class="sc">~</span> ., <span class="at">data =</span> data.train)</span></code></pre></div>
<p></p>
<p><strong>Step 4</strong> is to use the <code>prp()</code> function to plot the decision tree<label for="tufte-sn-28" class="margin-toggle sidenote-number">28</label><input type="checkbox" id="tufte-sn-28" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">28</span> <code>prp()</code> is a capable function. It has many arguments to specify the details of how the tree should be drawn. Use <code>help(prp)</code> to see details.</span></p>
<p></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4 -&gt; draw the tree</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">prp</span>(tree, <span class="at">nn.cex =</span> <span class="dv">1</span>)</span></code></pre></div>
<p></p>
<p>And the decision tree is shown in Figure <a href="#fig:f2-15">12</a>.</p>
<p><strong>Step 5</strong> is to prune the tree using the R function <code>prune()</code>. Remember that the parameter <code>cp</code> controls the model complexity<label for="tufte-sn-29" class="margin-toggle sidenote-number">29</label><input type="checkbox" id="tufte-sn-29" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">29</span> A larger <code>cp</code> leads to a less complex tree.</span>.</p>
<p>Let us try <code>cp</code> <span class="math inline">\(= 0.03\)</span>. This leads to a decision tree as shown in Figure <a href="#fig:f2-16">13</a>.</p>
<p></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 5 -&gt; prune the tree</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>tree <span class="ot">&lt;-</span> <span class="fu">prune</span>(tree,<span class="at">cp=</span><span class="fl">0.03</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">prp</span>(tree,<span class="at">nn.cex=</span><span class="dv">1</span>)</span></code></pre></div>
<p></p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-16"></span>
<img src="graphics/2_16.png" alt="The pruned decision tree model to predict `DX_bl` of the AD data with `cp = 0.03`" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 13: The pruned decision tree model to predict <code>DX_bl</code> of the AD data with <code>cp = 0.03</code><!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p><strong>Step 6</strong> is to evaluate the trained model by predicting the testing data.</p>
<p></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 6 -&gt; Predict using your tree model</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>pred.tree <span class="ot">&lt;-</span> <span class="fu">predict</span>(tree, data.test, <span class="at">type=</span><span class="st">&quot;class&quot;</span>)</span></code></pre></div>
<p></p>
<p>And we can evaluate the prediction performance using error rate.</p>
<p></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># The following line calculates the prediction error</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co"># rate (a number from 0 to 1) for a binary classification problem</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>err.tree <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">which</span>(pred.tree <span class="sc">!=</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>                           data.test<span class="sc">$</span>DX_bl))<span class="sc">/</span><span class="fu">length</span>(pred.tree)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) which(pred.tree != data$DX_bl) identifies the locations</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="co">#    of the incorrect predictions;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) length(any vector) returns the length of that vector;</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) thus, the ratio of incorrect prediction over the total</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co">#    prediction is the prediction error</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(err.tree)</span></code></pre></div>
<p></p>
</div>
</div>
<div id="remarks" class="section level2 unnumbered">
<h2>Remarks</h2>
<div id="statistical-model-vs.-causal-model" class="section level3 unnumbered">
<h3>Statistical model vs. causal model</h3>
<p>People unconsciously interprets a regression model as a causal model. When an unconscious interpretation is stated, it seems absurd and untrue, but it is fair to say that the line between a statistical model and a causal model is often blurred. We cannot blame ourselves for falling for this temptation before we have had a chance to see it through a critical lens, since both models share the same representation: an asymmetric form where predictors are on one side of the equation and the outcome is on the other side. Plus, the concept of <em>significance</em> is no less confusing: a common misinterpretation is to treat the <em>statistical significance</em> of a predictor as evidence of <em>causal significance</em> in the application context. The fact is that statistical significance doesn’t imply that the relationship between the predictor and the outcome variable is causal.</p>
<p>To see this, in what follows we will show an example that the statistical significance of a variable would disappear when some other variables are added into the model. Still using the AD dataset, we fit a regression model using the variable <code>AGE</code> only.</p>
<p></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>lm.AD.age <span class="ot">&lt;-</span> <span class="fu">lm</span>(MMSCORE <span class="sc">~</span> AGE, <span class="at">data =</span> AD)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(lm.AD.age)</span></code></pre></div>
<p></p>
<p>And the result is shown below.</p>
<p></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="do">## lm(formula = MMSCORE ~  AGE, data = AD)</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="do">##     Min      1Q  Median      3Q     Max</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="do">## -8.7020 -0.9653  0.6948  1.6182  2.5447</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="do">##             Estimate Std. Error t value Pr(&gt;|t|)</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="do">## (Intercept) 30.44147    0.94564  32.191   &lt;2e-16 ***</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="do">## AGE         -0.03333    0.01296  -2.572   0.0104 *</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="do">## Residual standard error: 2.11 on 515 degrees of freedom</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.01268,    Adjusted R-squared:  0.01076</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a><span class="do">## F-statistic: 6.614 on 1 and 515 DF,  p-value: 0.0104</span></span></code></pre></div>
<p></p>
<p>The predictor, <code>AGE</code>, is significant since its <em>p-value</em> is <span class="math inline">\(0.0104\)</span>.</p>
<p>Now let’s include more demographics variables into the model.</p>
<p></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fit the multiple linear regression model </span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co"># with more than one predictor</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>lm.AD.demo <span class="ot">&lt;-</span> <span class="fu">lm</span>(MMSCORE <span class="sc">~</span>  AGE <span class="sc">+</span> PTGENDER <span class="sc">+</span> PTEDUCAT,</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> AD)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(lm.AD.demo)</span></code></pre></div>
<p></p>
<p>And the result is shown below.</p>
<p></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="do">## lm(formula = MMSCORE ~ AGE + </span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="do">##    PTGENDER + PTEDUCAT, data = AD)</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="do">##     Min      1Q  Median      3Q     Max</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="do">## -8.4290 -0.9766  0.5796  1.4252  3.4539</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="do">##             Estimate Std. Error t value Pr(&gt;|t|)</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="do">## (Intercept) 27.70377    1.11131  24.929  &lt; 2e-16 ***</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="do">## AGE         -0.02453    0.01282  -1.913   0.0563 .</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="do">## PTGENDER    -0.43356    0.18740  -2.314   0.0211 *</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="do">## PTEDUCAT     0.17120    0.03432   4.988 8.35e-07 ***</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="do">## Residual standard error: 2.062 on 513 degrees of freedom</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.0612, Adjusted R-squared:  0.05571</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="do">## F-statistic: 11.15 on 3 and 513 DF,  p-value: 4.245e-07</span></span></code></pre></div>
<p></p>
<p>Now we can see that the predictor <code>AGE</code> is on the boardline of significance with a <em>p-value</em> <span class="math inline">\(0.0563\)</span>. The other predictors, <code>PTGENDER</code> and <code>PTEDUCAT</code>, are significant. The reason that the predictor <code>AGE</code> is now no longer significant is an interesting phenomenon, but it is not unusual in practice that a significant predictor becomes insignificant when other variables are included or excluded<label for="tufte-sn-30" class="margin-toggle sidenote-number">30</label><input type="checkbox" id="tufte-sn-30" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">30</span> This is because of the statistical dependence of the estimation of the predictors. Remember that <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\hat{\beta}\)</span> are two different entities. In the ground truth the two regression coefficients, <span class="math inline">\(\beta_i\)</span> and <span class="math inline">\(\beta_j\)</span>, may be independent with each other, but <span class="math inline">\(\hat{\beta}_i\)</span> and <span class="math inline">\(\hat{\beta}_j\)</span> could still be correlated.
As we have known that
<span class="math display">\[\begin{equation*}
\small

\operatorname{cov}(\widehat{\boldsymbol{\beta}})=\sigma_{\epsilon}^{2}\left(\boldsymbol{X}^{T} \boldsymbol{X}\right)^{-1},
 
\end{equation*}\]</span>
as long as <span class="math inline">\(\boldsymbol{X}^{T} \boldsymbol{X}\)</span> is not an identity matrix, the estimators of the regression parameters are dependent in a complicated and data-dependant way. Due to this reason, we need to be cautious about how to interpret the estimated regression parameters, as they are interrelated constructs.</span>.</p>
<p>One strategy to mitigate this problem is to explore your data from every possible angle, and try out different model formulations. The goal of your data analysis is not to get a final conclusive model that dictates the rest of the analysis process. The data analysis is an exploratory and dynamic process, i.e., as you see, the dynamic interplay of the variables, how they impact each others’ significance in predicting the outcome, is something you could only obtain by analyzing the data in an exploratory and dynamic way. The fact that a model fits the data well and passes the significance test only means that there is nothing significant in the data that is found to be against the model. The goodness-of-fit of the data doesn’t mean that the data says this model is the only causal model and other models are impossible.</p>
</div>
<div id="design-of-experiments" class="section level3 unnumbered">
<h3>Design of experiments</h3>
<p>Related to this issue of “statistical model vs. causal model,” the design of experiments (DOE) is a discipline which provides systematic data collection procedures to render the regression model as a causal model. How this could be done demands a lengthy discussion and illustration<label for="tufte-sn-31" class="margin-toggle sidenote-number">31</label><input type="checkbox" id="tufte-sn-31" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">31</span> Interested readers may start with this book: Goos, P. and Jones, B., <em>Optimal Design of Experiments: A Case Study Approach</em>, Wiley, 2011.</span>. Here, we briefly review its foundation to see why it has the connection with a linear regression model.</p>
<p>We have seen in Eq. <a href="#eq:2-betaDist-matrix">(6)</a> that the uncertainty of <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> comes from two sources, the noise in the data that is encoded in <span class="math inline">\(\sigma_{\epsilon}^{2}\)</span>, and the structure of <span class="math inline">\(\boldsymbol{X}\)</span>. <span class="math inline">\(\sigma_{\epsilon}^{2}\)</span> reflects essential uncertainty inherent in the system, but <span class="math inline">\(\boldsymbol{X}\)</span> is about how we collect the data. Thus, experimental design methods seek to optimize the structure of <span class="math inline">\(\boldsymbol{X}\)</span> such that the uncertainty of <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> could be minimized.</p>
<p>For example, suppose that there are three predictors. Let’s consider the following structure of <span class="math inline">\(\boldsymbol{X}\)</span></p>
<p><span class="math display">\[\begin{equation*}
\small
  
\boldsymbol{X}=\left[ \begin{array}{lll}{1} &amp; {0} &amp; {0} \\ {0} &amp; {1} &amp; {0} \\ {0} &amp; {0} &amp; {1} \end{array}\right].
 
\end{equation*}\]</span></p>
<p>It can be seen that, with this structure, the variance of <span class="math inline">\(\widehat{\boldsymbol{\beta}}\)</span> is<label for="tufte-sn-32" class="margin-toggle sidenote-number">32</label><input type="checkbox" id="tufte-sn-32" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">32</span> <span class="math inline">\(\boldsymbol{I}\)</span> is the identity matrix. Here, <span class="math inline">\(\boldsymbol{I}_3 = \left[ \begin{array}{lll}{1} &amp; {0} &amp; {0} \\ {0} &amp; {1} &amp; {0} \\ {0} &amp; {0} &amp; {1} \end{array}\right].\)</span></span></p>
<p><span class="math display">\[\begin{equation*}
\small
  cov(\hat{\boldsymbol{\beta}})=\sigma_{\epsilon}^2\boldsymbol{I}_3. 
\end{equation*}\]</span></p>
<p>In other words, we can draw two main observations. First, the estimations of the regression parameters are now independent, given that their correlations are zero. Second, the variances of the estimated regression parameters are the same. Because of these two traits, this data matrix <span class="math inline">\(\boldsymbol X\)</span> is ideal and adopted in DOE to create <em>factorial designs</em>. For a linear regression model built on a dataset with such a data matrix, adding or deleting variables from the regression model will not result in changes of the estimations of other parameters.</p>
</div>
<div id="the-pessimistic-error-estimation-in-post-pruning" class="section level3 unnumbered">
<h3>The pessimistic error estimation in post-pruning</h3>
<p>Let’s look at the tree in Figure <a href="#fig:f2-13">14</a>. It has one root node, one inner node, and three leaf nodes. The target for tree pruning, for this example, is the inner node. In other words, should we prune the inner node and its subsequent child nodes?</p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-13"></span>
<img src="graphics/2_13.png" alt="An example of tree pruning using pessimistic error" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 14: An example of tree pruning using pessimistic error<!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p>We have mentioned that if the improvement on error is not significant, we should prune the node. Let’s denote the <strong>empirical error rate</strong><label for="tufte-sn-33" class="margin-toggle sidenote-number">33</label><input type="checkbox" id="tufte-sn-33" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">33</span> Empirical error is derived based on the training data.</span> as <span class="math inline">\(\hat e\)</span>. The reason we give the notation a <em>hat</em> is because it is only an estimate of an underlying parameter, the true error <span class="math inline">\(e\)</span>. <span class="math inline">\(\hat e\)</span> is usually smaller than <span class="math inline">\(e\)</span>, and thus, it is considered to be optimistic. To create a fairer estimate of <span class="math inline">\(e\)</span>, the <strong>pessimistic error estimation</strong> approach is used for tree pruning.</p>
<p>The pessimistic error estimation, like a regression model, builds on a hypothesized data-generating mechanism. Here, the <em>data</em> is the <em>errors</em> we observed from the training data. A data point can be either correctly or wrongly classified, and we can view the probability of being wrongly classified as a Bernoulli trial, while the parameter of this Bernoulli trial, commonly denoted as <span class="math inline">\(p\)</span>, is <span class="math inline">\(e\)</span>. If we denote the total number of errors we have observed on the <span class="math inline">\(n\)</span> data points as <span class="math inline">\(d\)</span>, we can derive that <span class="math inline">\(d\)</span> is distributed as a binomial distribution. We can write this data-generating mechanism as</p>
<p><span class="math display">\[\begin{equation*}
\small
  
d \sim Bino\left(n, e\right).
 
\end{equation*}\]</span></p>
<p>Since <span class="math inline">\(n\)</span> is usually large, we can use the normal approximation for the binomial distribution</p>
<p><span class="math display">\[\begin{equation*}
\small
  
d \sim N\left(ne, ne(1-e)\right).
 
\end{equation*}\]</span></p>
<p>As <span class="math inline">\(\hat e = d/n\)</span>, we have</p>
<p><span class="math display">\[\begin{equation*}
\small
  
\hat e \sim N\left(e, \frac{e(1-e)}{n}\right).
 
\end{equation*}\]</span></p>
<p>Skipping further derivations (more assumptions are imposed, indeed, to derive the following conclusion), we can derive the confidence interval of <span class="math inline">\(e\)</span> as</p>
<p><span class="math display">\[\begin{equation*}
\small
  \hat e - z_{\alpha/2} \sqrt{\frac{\hat{e}(1-\hat{e})}{n}} \leq e \leq \hat{e} +z_{\alpha/2} \sqrt{\frac{\hat{e}(1-\hat{e})}{n}}. 
\end{equation*}\]</span></p>
<p>The upper bound of the interval, <span class="math inline">\(\hat{e} +z_{\alpha/2} \sqrt{\frac{\hat{e}(1-\hat{e})}{n}}\)</span>, is named as the <em>pessimistic error</em>. The tree pruning methods that use the <em>pessimistic error</em> are motivated by a conservative perspective.</p>
<p>The pessimistic error depends on three values: <span class="math inline">\(\alpha\)</span>, which is often set to be <span class="math inline">\(0.25\)</span> so that <span class="math inline">\(z_{\alpha/2}=1.15\)</span>; <span class="math inline">\(\hat e\)</span>, which is the training error rate; and <span class="math inline">\(n\)</span>, which is the number of data points at the node<label for="tufte-sn-34" class="margin-toggle sidenote-number">34</label><input type="checkbox" id="tufte-sn-34" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">34</span> The pessimistic error is larger with a smaller <span class="math inline">\(n\)</span>, an estimation method that accounts for the sample size.</span>.</p>
<p>Now let’s revisit Figure <a href="#fig:f2-13">14</a>.</p>
<p>First, let’s derive the pessimistic errors for the two child nodes of the inner node. The empirical error rate for the left child node is <span class="math inline">\(\hat e = \frac{9}{19}=0.4737\)</span>. For the pessimistic error, we can get that</p>
<p><span class="math display">\[\begin{equation*}
\small
  \hat{e} +z_{\alpha/2} \sqrt{\frac{\hat{e}(1-\hat{e})}{n}} = 0.4737 + 1.15\sqrt{\frac{0.4737(1-0.4737)}{19}}=0.605. 
\end{equation*}\]</span></p>
<p>With this error rate, for a node with <span class="math inline">\(19\)</span> data points, the total misclassified data points can be <span class="math inline">\(mp=0.605\times 19=11.5\)</span>.</p>
<p>For the right child node, the empirical error rate is <span class="math inline">\(\hat e = \frac{9}{20}=0.45\)</span>. For the pessimistic error, we can get that</p>
<p><span class="math display">\[\begin{equation*}
\small
  \hat{e} +z_{\alpha/2} \sqrt{\frac{\hat{e}(1-\hat{e})}{n}} = 0.45 + 1.15\sqrt{\frac{0.45(1-0.45)}{20}}=0.578. 
\end{equation*}\]</span></p>
<p>With this error rate, for a node with <span class="math inline">\(20\)</span> data points, the total misclassified data points can be <span class="math inline">\(mp=0.578\times 20=11.56\)</span>.</p>
<p>Thus, if we keep this branch, the total misclassified data points would be <span class="math inline">\(mp=11.5+11.56=23.06\)</span>.</p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-14"></span>
<img src="graphics/2_14.png" alt="The pruned tree of Figure \@ref(fig:f2-13)" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 15: The pruned tree of Figure <a href="#fig:f2-13">14</a><!--</p>-->
<!--</div>--></span>
</p>
<p></p>
<p>Now let’s evaluate the alternative: to cut the branch. This means the inner node will become a decision node, as shown in Figure <a href="#fig:f2-14">15</a>. We will label the new decision node as C1, since <span class="math inline">\(20\)</span> of the included data points are labeled as C1, while <span class="math inline">\(19\)</span> are labeled as C2. The empirical error rate <span class="math inline">\(e\)</span> is <span class="math inline">\(\hat e = \frac{19}{39}=0.4871\)</span>. For the pessimistic error, we can get that</p>
<p><span class="math display">\[\begin{equation*}
\small
  \hat{e} +z_{\alpha/2} \sqrt{\frac{\hat{e}(1-\hat{e})}{n}} = 0.4871 + 1.15\sqrt{\frac{0.4871(1-0.4871)}{39}}=0.579. 
\end{equation*}\]</span></p>
<p>With this error rate, for a dataset with 39 data points, the total misclassified data points can be <span class="math inline">\(mp=0.579\times 39=22.59\)</span>. This is what would happen if we prune the tree. As <span class="math inline">\(22.59 &lt; 23.06\)</span>, pruning is a better decision.</p>
<p>The pruned tree is shown in Figure <a href="#fig:f2-14">15</a>. A complete post-pruning method will continue to consider further pruning: now consider pruning the child nodes of the root node. Following the process outlined above, the would-be misclassified data points based on the pessimistic error rate at the root node is <span class="math inline">\(22.92\)</span>, and the total misclassified instances based on the pessimistic error rate from its child nodes is <span class="math inline">\(22.59+0=22.59\)</span>. Pruning the child nodes would lead to increased error. Thus, no further pruning is needed: the child nodes are kept and the final tree consists of three nodes.</p>
</div>
</div>
<div id="exercises" class="section level2 unnumbered">
<h2>Exercises</h2>
<p></p>
<p><!--
<caption>--><span class="marginnote shownote"><span id="tab:t2-HW-lr">Table 2: </span>Dataset for building a linear regression model</span><!--</caption>--></p>
<table>
<thead>
<tr class="header">
<th align="left">ID</th>
<th align="left"><span class="math inline">\(x_1\)</span></th>
<th align="left"><span class="math inline">\(x_2\)</span></th>
<th align="left"><span class="math inline">\(y\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(-0.15\)</span></td>
<td align="left"><span class="math inline">\(-0.48\)</span></td>
<td align="left"><span class="math inline">\(0.46\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(2\)</span></td>
<td align="left"><span class="math inline">\(-0.72\)</span></td>
<td align="left"><span class="math inline">\(-0.54\)</span></td>
<td align="left"><span class="math inline">\(-0.37\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(3\)</span></td>
<td align="left"><span class="math inline">\(1.36\)</span></td>
<td align="left"><span class="math inline">\(-0.91\)</span></td>
<td align="left"><span class="math inline">\(-0.27\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(4\)</span></td>
<td align="left"><span class="math inline">\(0.61\)</span></td>
<td align="left"><span class="math inline">\(1.59\)</span></td>
<td align="left"><span class="math inline">\(1.35\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(5\)</span></td>
<td align="left"><span class="math inline">\(-1.11\)</span></td>
<td align="left"><span class="math inline">\(0.34\)</span></td>
<td align="left"><span class="math inline">\(-0.11\)</span></td>
</tr>
</tbody>
</table>
<p></p>
<p><!-- begin{enumerate} --></p>
<p>1. Here let’s consider the dataset in Table <a href="#tab:t2-HW-lr">2</a>. Let’s build a linear regression model, i.e.,
<span class="math display">\[\begin{equation*}
\small
  
    y = \beta_{0}+\beta_{1}x_1 +\beta_{2}x_2 + \epsilon,
     
\end{equation*}\]</span>
and
<span class="math display">\[\begin{equation*}
\small
  
    \epsilon \sim N\left(0, \sigma_{\varepsilon}^{2}\right).
     
\end{equation*}\]</span>
and calculate the regression parameters <span class="math inline">\(\beta_{0},\beta_{1},\beta_{2}\)</span> manually.</p>
<p>2. Follow up the data on Q1. Use the R pipeline to build the linear regression model. Compare the result from R and the result by your manual calculation.</p>
<p>3. Read the following output in R.</p>
<p><!-- end{enumerate} --></p>
<p></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="do">## lm(formula = y ~ ., data = data)</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="do">##       Min        1Q    Median        3Q       Max </span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="do">## -0.239169 -0.065621  0.005689  0.064270  0.310456 </span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="do">##              Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="do">## (Intercept)  0.009124   0.010473   0.871    0.386    </span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="do">## x1           1.008084   0.008696 115.926   &lt;2e-16 ***</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="do">## x2           0.494473   0.009130  54.159   &lt;2e-16 ***</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="do">## x3           0.012988   0.010055   1.292    0.200    </span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="do">## x4          -0.002329   0.009422  -0.247    0.805    </span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="do">## Residual standard error: 0.1011 on 95 degrees of freedom</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.9942, Adjusted R-squared:  0.994 </span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a><span class="do">## F-statistic:  4079 on 4 and 95 DF,  p-value: &lt; 2.2e-16</span></span></code></pre></div>
<p></p>
<p><!-- begin{enumerate}[resume] --></p>
<p>4. (a) Write the fitted regression model. (b) Identify the significant variables. (c) What is the R-squared of this model? Does the model fit the data well? (d) What would you recommend as the next step in data analysis?</p>
<p>5. Consider the dataset in Table <a href="#tab:t2-hw-dt">3</a>. Build a decision tree model by manual calculation. To simplify the process, let’s only try three alternatives for the splits: <span class="math inline">\(x_1\geq0.59\)</span>, <span class="math inline">\(x_1\geq0.37\)</span>, and <span class="math inline">\(x_2\geq0.35\)</span>.</p>
<p></p>
<p><!--
<caption>--><span class="marginnote shownote"><span id="tab:t2-hw-dt">Table 3: </span>Dataset for building a decision tree</span><!--</caption>--></p>
<table>
<thead>
<tr class="header">
<th align="left">ID</th>
<th align="left"><span class="math inline">\(x_1\)</span></th>
<th align="left"><span class="math inline">\(x_2\)</span></th>
<th align="left"><span class="math inline">\(y\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(0.22\)</span></td>
<td align="left"><span class="math inline">\(0.38\)</span></td>
<td align="left">No</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(2\)</span></td>
<td align="left"><span class="math inline">\(0.58\)</span></td>
<td align="left"><span class="math inline">\(0.32\)</span></td>
<td align="left">Yes</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(3\)</span></td>
<td align="left"><span class="math inline">\(0.57\)</span></td>
<td align="left"><span class="math inline">\(0.28\)</span></td>
<td align="left">Yes</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(4\)</span></td>
<td align="left"><span class="math inline">\(0.41\)</span></td>
<td align="left"><span class="math inline">\(0.43\)</span></td>
<td align="left">Yes</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(5\)</span></td>
<td align="left"><span class="math inline">\(0.6\)</span></td>
<td align="left"><span class="math inline">\(0.29\)</span></td>
<td align="left">No</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(6\)</span></td>
<td align="left"><span class="math inline">\(0.12\)</span></td>
<td align="left"><span class="math inline">\(0.32\)</span></td>
<td align="left">Yes</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(7\)</span></td>
<td align="left"><span class="math inline">\(0.25\)</span></td>
<td align="left"><span class="math inline">\(0.32\)</span></td>
<td align="left">Yes</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(8\)</span></td>
<td align="left"><span class="math inline">\(0.32\)</span></td>
<td align="left"><span class="math inline">\(0.38\)</span></td>
<td align="left">No</td>
</tr>
</tbody>
</table>
<p></p>
<p>6. Follow up on the dataset in Q5. Use the R pipeline for building a decision tree model. Compare the result from R and the result by your manual calculation.</p>
<p>7. Use the <code>mtcars</code> dataset in R, select the variable <code>mpg</code> as the outcome variable and other variables as predictors, run the R pipeline for linear regression, and summarize your findings.</p>
<p>8. Use the <code>mtcars</code> dataset in R, select the variable <code>mpg</code> as the outcome variable and other variables as predictors, run the R pipeline for decision tree, and summarize your findings. Another dataset is to use the <code>iris</code> dataset, select the variable <code>Species</code> as the outcome variable (i.e., to build a classification tree).</p>
<p>9. Design a simulated experiment to evaluate the effectiveness of the <code>lm()</code> in R. For instance, you can simulate <span class="math inline">\(100\)</span> samples from a linear regression model with <span class="math inline">\(2\)</span> variables,
<span class="math display">\[\begin{equation*}
\small
  
    y = \beta_{1}x_1 +\beta_{2}x_2 + \epsilon,
     
\end{equation*}\]</span>
where <span class="math inline">\(\beta_{1} = 1\)</span>, <span class="math inline">\(\beta_{2} = 1\)</span>, and
<span class="math display">\[\begin{equation*}
\small
  
    \epsilon \sim N\left(0, 1\right).
     
\end{equation*}\]</span>
You can simulate <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span> using the standard normal distribution <span class="math inline">\(N\left(0, 1\right)\)</span>. Run <code>lm()</code> on the simulated data, and see how close the fitted model is with the true model.</p>
<p>10. Follow up on the experiment in Q9. Let’s add two more variables <span class="math inline">\(x_3\)</span> and <span class="math inline">\(x_4\)</span> into the dataset but still generate <span class="math inline">\(100\)</span> samples from a linear regression model from the same underlying model
<span class="math display">\[\begin{equation*}
\small
  
    y = \beta_{1}x_1 +\beta_{2}x_2 + \epsilon,
     
\end{equation*}\]</span>
where <span class="math inline">\(\beta_{1} = 1\)</span>, <span class="math inline">\(\beta_{2} = 1\)</span>, and
<span class="math display">\[\begin{equation*}
\small
  
    \epsilon \sim N\left(0, 1\right).
     
\end{equation*}\]</span></p>
<p></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:f2-hw-dt"></span>
<img src="graphics/2_hw_dt.png" alt="The true model for simulation experiment in Q12" width="100%"  />
<!--
<p class="caption marginnote">-->Figure 16: The true model for simulation experiment in Q12<!--</p>-->
<!--</div>--></span>
</p>
<p>
In other words, <span class="math inline">\(x_3\)</span> and <span class="math inline">\(x_4\)</span> are insignificant variables. You can simulate <span class="math inline">\(x_1\)</span> to <span class="math inline">\(x_4\)</span> using the standard normal distribution <span class="math inline">\(N\left(0, 1\right)\)</span>. Run <code>lm()</code> on the simulated data, and see how close the fitted model is with the true model.</p>
<p><!-- end{enumerate} --></p>
<p><!-- begin{enumerate}[resume] --></p>
<p>11. Follow up on the experiment in Q10. Run <code>rpart()</code> on the simulated data, and see how close the fitted model is with the true model.</p>
<p>12. Design a simulated experiment to evaluate the effectiveness of the <code>rpart()</code> in R package <code>rpart</code>. For instance, you can simulate <span class="math inline">\(100\)</span> samples from a tree model as shown in Figure <a href="#fig:f2-hw-dt">16</a>, run <code>rpart()</code> on the simulated data, and see how close the fitted model is with the true model.</p>
<p><!-- end{enumerate} --></p>
<!-- \begin{figure*} -->
<!--    \centering -->
<!--    \checkoddpage \ifoddpage \forcerectofloat \else \forceversofloat \fi -->
<!--    \includegraphics[width = 0.05\textwidth]{graphics/9points_4lines2.png} -->
<!-- \end{figure*} -->

</div>
</div>
<p style="text-align: center;">
</p>
</div>
</div>

<script src="js/jquery.js"></script>
<script src="js/tablesaw-stackonly.js"></script>
<script src="js/nudge.min.js"></script>


<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

</body>
</html>
